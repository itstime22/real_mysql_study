[**노션 정리**](https://sweltering-diadem-a68.notion.site/2bb55b9ff8dd80ee8075e01a8dd7beb9?pvs=74)
# 인덱스
# 1. 디스크 읽기 방식

디스크와 같은 기계식 장치 (데이터 저장 매체)는 컴퓨터에서 **가장 느린 부분**이기에 **디스크 I/0를 줄이는 것이 데이터베이스 성능 튜닝의 중요 쟁점** 

## 📌 **하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)**

- **하드 디스크 드라이브 (HDD)**
    - **기계식 장치 → 데이터베이스 서버에서의 병목 원인**
    - 디스크 원판 기계적 회전 → **느린 읽기/쓰기**
- **솔리드 스테이트 드라이브 (SSD)**
    - **전자식 저장 매체 (HDD 대체 가능)**
    - HDD와 **같은 인터페이스를 지원**하기에 내장디스크/DAS/SAN에 그대로 사용 가능
    - HDD에서 플래터 대신 **플래시 메모리 장착** → 디스크 원판의 기계적 회전이 없기에 **빠른 데이터 읽기/쓰기 (랜덤 I/0)**가능
    - 순차 I/O에서는 HDD와 비슷하거나 조금 빠름 
    데이터베이스 서버에서 랜덤 I/O를 통한 작은 데이터의 읽기/쓰기 작업이 대부분
    → SSD가 DBMS용 스토리지에 최적 (최근 DBMS용 서버는 대부분 SSD 채택 )
    
- **SSD와 HDD의 랜덤 I/O 성능 비교 (성능 벤치마크 예시)**
    - SSD : 초당 436개의 트랜잭션 처리
    - HDD : 초당 60개 트랜잭션 처리
        
        → 이와 같이 일반적인 **웹 서비스(OLTP) 환경의 데이터베이스에서는 SSD가 월등한 속도**
        

## 📌 **랜덤 I/O와 순차 I/O**

**랜덤 I/O**: HDD의 **플래터를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동**시킨 다음 데이터를 읽는 것 (순차 I/O도 이와 동일한 과정)

- **순차I/O** : 3개의 페이지를 디스크에 기록 → 1번의 시스템 콜 요청
- **랜덤I/O** : 3개의 페이지를 디스크에 기록 → 3번의 시스템 콜 호출
    
    → 디스크에 기록해야 할 위치를 찾기 위해 **헤드 움직이는 수** 다름 
    → 즉, 랜덤 I/O보다 **순차 I/O가 3배 빠름** (읽기/쓰기에 걸리는 시간 결정하기에)
    
- **디스크의 성능**은 **디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한번에 기록**하느냐에 결정
(여러번 읽기/쓰기를 요청하는 랜덤 I/O 작업이 작업 부하가 큼)

- 디스크 원판이 없는 SSD에서도 랜덤 I/O와 순차 I/O의 차이가 있음
→ 랜덤 I/O가 전체 스루풋이 떨어짐 (성능 낮음)
- **RAID 컨트롤러**: **캐시 메모리**가 장착됐으며 데이터베이스 서버에서 일반적으로 사용
→ 랜덤 I/O와 순차 I/O 모두 쓰기 실행 시, **동기화 작업이 필요한데 이때 순차 I/O가 비효율적**으로 처리되기에 **RAID 컨트롤러로 순차 I/O가 효율적으로 처리될 수 있게 변환**
- **쿼리 튜닝 → 랜덤IO를 줄이는 것이 목적** (쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리 개선)

# 2. 인덱스란?

**인덱스: 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍 (Key-Value pair)으로 지정**

- 인덱스 → 찾아보기 (빠르게 찾아갈 수 있게 정렬됨)
- 데이터 파일 → 책의 내용
- 레코드 주소 → 페이지 번호
- **칼럼의 값을 주어진 순서로 미리 정렬**해서 보관 (책의 찾아보기나 SortedList 자료구조처럼)
- 인덱서의 장단점: (SortedList 자료 구조처럼) **INSERT, UPDATE, DELETE의 처리(데이터 저장)는 느려지지만**, **SELECT의 처리(데이터 읽기)는 빠름** → 트레이드 오프
- **인덱스의 추가 여부**는 **저장 속도, 읽기 속도를 고려**하여 결정 (SELECT 쿼리라고 무조건 인덱스 생성 시, 저장 성능이 떨어지고 인덱스 크기가 비대해져 역효과)

- 인덱스의 구분 (**역할별**) → **프라이머리 키**와 **보조 키(세컨더리 인덱스)**로 구분
- 인덱스의 구분 (**데이터 저장 방식=알고리즘**) → **B-Tree 인덱스**와 **해시 인덱스** 등으로 구분
- 인덱스의 구분 (**데이터 중복 허용 여부**) → **Unique 인덱스**와 **Non - Unique  인덱스**로 구분
    - 같은 값이 1개 또는 1개 이상 존재할 수 있는지 → 실제 DBMS의 쿼리를 실행해야하는 옵티마이저에게 중요한 문제
- 인덱스의 구분 (**기능별**) → **전문 검색용 인덱스**와 **공간 검색용 인덱스** 등으로 구분

# 3. B-Tree 인덱스

**B-Tree: 칼럼의 원래 값을 변형시키지 않고, 구조체 내에서 항상 정렬된 상태로 유지**

- 가장 일반적인 인덱싱 알고리즘으로 현재도 범용적으로 사용됨
- B는 바이너리가 아닌, Balanced 의미

## 📌 구조 및 특성

- B-Tree의 구조: 트리 구조 → **최상위에 하나의 루트 노드** + **그 하위에 자식 노드**
    - **루트 노드**: 최상위에 있는 노드
    - **리프 노드**: 가장 하위에 있는 노드 → **항상 실제 데이터 레코드를 찾아가기 위한 주솟값**을 가지고 있음. (인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 하기에)
    - **브랜치 노드**: 루트 노드와 브랜치 노드 사이
- 대부분 RDMS의 데이터 파일에서 **레코드**는 특정 기준으로 정렬 X → **임의의 순서로 저장**
- but, **InnoDB 테이블에서 레코드**는 기본적으로 클러스터링 되어 **PK 순서로 정렬되어 저장**

- MyISAM 테이블 → 세컨더리 인덱스가 물리적인 주소를 가짐
- InnoDB 테이블 → 프라이머리 키를 주소처럼 사용하기에 논리적인 주소를 가짐 (즉, 바로 찾아가지못하고 프라이머리 키를 저장하고 있는 B-Tree 다시 한번 검색 필요)

## 📌 **B-Tree 인덱스 키 추가 및 삭제**

테이블의 레코드를 저장/변경하는 경우 인덱스 키 추가/삭제 작업 발생 → 이를 통해 쿼리의 성능 쉽게 예측 가능

### ✅ **인덱스 키 추가**

- **새로운 키 값이 B-Tree에 저장** → 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 안될 수도 / 저장될 키 값을 이용해 **B-Tree 상의 적절한 위치 검색 필요**
    - 위치 결정되면 **레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장**
    - 리프 노드가 꽉 차서 더이상 저장할 수 없을때는 **리프 노드가 분리(split) 필요**
    → 상위 브랜치 노드까지 처리의 범위 넓어짐
        
        → 이 특성으로 **B-Tree는 쓰기작업에 비용이 많이 듬**
        
- **인덱스 추가로 인한 비용**
    - 대략 테이블에 레코드를 추가하는 작업을 1이라 설정하면, 인덱스에 키를 추가하는 작업은 1.5정도로 예측
    ex) 테이블에 인덱스가 하나도 없다면 작업 비용은 1, 인덱스가 3개 라면 5.5(1.5*3+1)
    - 해당 비용은 **디스크로부터 인덱스 페이지를 읽고 쓰는 것에 걸리는 시간**

### ✅ **인덱스 키 삭제**

- **키 값이 저장된 리프 노드를 찾아 삭제 마크 → 방치하거나 재활용 가능**
- 마킹 작업에 디스크 쓰기가 필요하므로 디스크 I/O 필요
- InnoDB 스토리지 엔진에서는 버퍼링되어 지연 처리 가능

### ✅ **인덱스 키 변경**

- 단순히 인덱스 상의 키 값 변경 불가
- **먼저 키 값을 삭제한 후, 다시 새로운 키를 추가**
- InnoDB 스토리지 엔진에서는 체인지 버퍼를 활용해 지연 처리 가능

### ✅ **인덱스 키 검색**

- **빠른 검색 가능 (추가 비용을 감당하면서 인덱스를 구축하는 이유)**
- 트리 탐색: 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 수행하는 비교 작업
- 인덱스 트리 탐색은 SELECT뿐만 아니라 UPDATE, DELETE에서도 사용
- B-Tree 인덱스를 이용한 검색은 **100% 일치 또는 값의 앞부분만 일치**하는 경우에 사용
- 부등호 비교 조건에서도 사용 가능, 뒷부분만 검색하는 용도로는 사용 X
- 인덱스 키 값에 변형이 가해진 후 비교될 때, B-Tree의 빠른 검색 사용 X
    
    → 변형된 값은 B-Tree 인덱스에 존재하는 값이 아니기에 **함수나 연산을 수행한 결과로 정렬 및 검색 시 장점 이용 불가**
    

## 📌 **B-Tree 인덱스 사용에 영향을 미치는 요소**

**B-Tree 인덱스는 칼럼의 크기, 레코드의 건수, 유니크한 인덱스 키 값의 개수 등에 의해 검색이나 변경 작업의 성능 영향**

### ✅ **인덱스 키 값의 크기**

- **페이지(=블록): 디스크에 데이터를 저장하는 가장 기본 단위** → **디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위**
- InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위
- 인덱스도 페이지 단위로 관리 (앞에서 루트/브랜치/리프 노드 구분한 기준)

- **B-Tree는 자식 노드의 개수가 가변적** → **인덱스의 페이지 크기와 키 값의 크기에 따라 결정**
- 페이지의 크기를 4 ~ 64KB로 선택할 수 있지만, 기본값은 16KB
    
    ex) 인덱스 키 16바이트 / 자식 노드 주소 12바이트로 가정
    한 개의 페이지(16KB) → 16∗1024/(16+12) = 585개의 자식 노드를 가질 수 있음
    
    인덱스 키 값이 32바이트 → 16*1024/(32+12) = 372개의 자식 노드를 가질 수 있음
    
    → **즉, 인덱스를 구성하는 키 값이 커지면 디스크 읽어야하는 횟수가 늘어나고 그만큼 느려짐**
    
    → **또한, 메모리에 캐시할 수 있는 레코드 수가 줄어들어 메모리 효율 떨어짐**
    

### ✅ **B-Tree 깊이**

- 깊이는 중요한 요소이지만 사용자가 제어할 수는 없음
- **인덱스 키 값의 크기가 커질수록** 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고 **B-Tree 깊이가 깊어져 디스크 읽기가 더 많이 필요**
    
    → **즉, 인덱스 키 값의 크기를 가능하면 작게 만드는 것이 좋음**
    

### ✅ **선택도 (기수성)**

- **선택도(=기수성): 모든 인덱스 키 값 가운데, 유니크한 값의 수 → 유니크한 값의 개수가 인덱스나 쿼리의 효율성에 큰 영향을 미침**
- 인덱스 키 값에 **중복된 값이 많아질 수록 선택도와 기수성은 낮아짐**
- **선택도가 높을수록, 검색 대상이 줄어들기에 빠르게 처리됨**
- 선택도가 좋지 않더라도 인덱스를 만드는 것이 나은 경우도 있으므로 여러가지 용도를 고려해 인덱스 설계해야됨

### ✅ **읽어야 하는 레코드의 건수**

- 인덱스를 이용한 읽기의 손인 분기점을 판단해야함
- 일반적인 DBMS의 옵티마이저에서는 **인덱스를 통해 레코드 1건을 읽는 것이** 테이블에서 직접 레코드 1건을 읽는 것 보다 **4~5배 정도 비용이 발생**
    
    → 즉, 인덱스를 통해 읽어야 할 레코드 건수가 전체 테이블 레코드의 **20~25퍼를 넘어서면 인덱스를 이용하지 않고 테이블을 직접 읽어서 필터링하는 방식이 효율적**
    

## 📌 **B-Tree 인덱스를 통한 데이터 읽기**

### ✅ **인덱스 레인지 스캔**

- **인덱스 레인지 스캔: 인덱스 접근 방법 중, 가장 대표적인 접근 방식 (빠름)**
    - 검색해야할 인덱스의 범위가 결정되었을 때 사용하는 방식
- 루프 노드에서 브랜치 노드를 거쳐 리프 노드까지 찾아들어가면 레코드 시작지점 찾을 수 있음
- 시작 지점을 찾으면 **리프 노드의 레코드만 순서대로 읽으면 됨 = 스캔**
- 리프 노드의 끝까지 읽으면 링크를 이용해 다음 리프 노드를 찾아 다시 스캔
- 스캔을 멈춰야할 위치에 도착하면 지금까지 읽은 레코드를 반환하고 쿼리 종료
- 리프 노드에서 검색 조건에 일치하면 데이터 파일에서 레코드를 읽어오는 과정 필요 → 랜덤 I/O가 일어나기에 **인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 듬** (**20~25퍼를 넘어서면 인덱스를 이용하지 않고 테이블을 직접 읽어서 필터링하는 방식이 효율적)**
- 인덱스 레인지 스캔 3단계
    1. 인덱스 탐색: 인덱스에서 조건을 만족하는 값이 저장된 위치 찾기
    2. 인덱스 스캔: 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 읽기
    3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드 읽기

### ✅ **인덱스 풀 스캔**

- **인덱스 풀 스캔**: (인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만) **처음부터 끝까지 모두 읽는 방식**
    - 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌 경우 사용되는 방식
    - ex) 인덱스는 (A, B, C) 칼럼의 순서 → 쿼리 조건절은 B칼럼이나 C칼럼으로 검색
- 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 인덱스 풀 스캔 사용
- 나머지 두 방식에 비해 **효율적이지 않기에** 일반적으로 사용되지는 않음

### ✅ **루스 인덱스 스캔**

- 오라클과 같은 DBMS의 인덱스 스킵 스캔과 작동 방식 비슷
- **루스 인덱스 스캔: 느슨하게 인덱스를 읽는 방식**
- 인덱스 레인지 스캔과 비슷하게 작동하지만, **중간에 필요치 않은 인덱스 키 값은 무시(SKIP)하고 다음으로 넘어가는 형태로 처리**
- GROUP BY 또는 집합 함수 MAX()나 MIN() 함수를 최적화 하는 것에 사용
- 예시
    
    ```jsx
    mysql> SELECT dept_no, MIN(emp_no)
           FROM dept_emp
           WHERE dep_no BETWEEN 'd002' AND 'd004'
           GROUP BY dept_no;
    ```
    
    - 위 쿼리에서 사용된 dept_emp 테이블은 dept_no, emp_no 두개의 컬럼으로 인덱스가 생성
    - 이 인덱스는 (dept_no, emp_no) 조합으로 정렬 → 그룹 별로 첫 번째 레코드의 emp_no값만 읽으면 됨
    - 즉, 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저가 알고 있기에 조건에 만족하지 않는 레코드는 무시하기 다음 레코드로 이동

### ✅ **인덱스 스킵 스캔**

- **인덱스 스킵 스캔: 옵티마이저가 특정 컬럼을 건너뛰고 인덱스 검색이 가능하게 해주는 방식**
    - MySQL 8.0부터 도입
    - 이전 버전에 루스 인덱스 스캔이 있었지만 GROUP BY 작업에만 적용 가능했음
    - 인덱스 스킵 스캔은 **WHERE 조건절의 검색**을 위해 사용 가능
- 예시
    
    ```jsx
    //인덱스 생성
    mysql> ALTER TABLE employees
           ADD INDEX ix_gender_birthdate (gender, birth_date);
           
    //인덱스를 사용하지 못하는 쿼리
    mysql> SELECT * FROM employees WHERE birth_date >= '1965-02-01';
    
    //인덱스를 사용할 수 있는 쿼리
    mysql> SELECT * FROM employees WHERE gender='M' AND birth_date >= '1965-02-01';      
    ```
    
    - 해당 인덱스를 사용하려면 **WHERE 조건절에 gender 칼럼에 대한 비교조건 필수**
        
        → 첫 번째 쿼리는 해당 비교 조건이 없기에 인덱스 사용 불가 (birth_date 칼럼부터 시작하는 인덱스 필요)
        
    - **인덱스 스킵 스캔 활성화 시, birth_date 칼럼만으로도 인덱스 검색 가능**
    - **비활성화 시, 인덱스를 효율적으로 사용하지 못함 (풀 인덱스 스캔)**
- 인덱스 스킵 스캔 단점
    1. WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 **유니크한 값의 개수가 적어야 함**
        
        (많으면 오히려 쿼리 처리 성능이 느려질 수도)
        
    2. **쿼리가 인덱스에 존재하는 칼럼만으로 처리** 가능해야 함(커버링 인덱스)

## 📌 **다중 칼럼 인덱스**

- **다중 칼럼 인덱스(=복합 컬럼 인덱스): 두 개 이상의 칼럼으로 구성된 인덱스**
- 각 컬럼이 앞의 컬럼에 의존하여 정렬되는 구조 → 인덱스 내에서 **각 칼럼의 칼럼 위치(순서)가 중요**

## 📌 **B-Tree 인덱스의 정렬 및 스캔 방향**

- (인덱스를 생성할 때 설정한) **정렬 규칙에 따라서 인덱스의 키 값은 항상 오름차순 또는 내림차순으로 정렬되어 저장** (오름차순으로 생성 → 꼭 오름차순으로 읽기 X)
- 읽는 방향은 쿼리에 따라 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정

### ✅ **인덱스의 정렬**

- 과거 버전에서는 정렬 순서를 혼합해서 사용 X
- MySQL 8.0버전부터는 **정렬 순서를 혼합한 인덱스** 생성 가능

```jsx
mysql> CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
```

### ✅ 인덱스 스캔 방향

```jsx
mysql> SELECT *
       FROM employees
       ORDER BY first_name DESC
       LIMIT 1;
```

- 이 쿼리문의 경우, first_name을 내림차순(DESC) 으로 정렬하고 맨 첫 번째 레코드를 조회하는 쿼리
- 인덱스는 항상 오름차순으로만 정렬되어있지만 오름차순으로 스캔하여 모든 레코드를 다 읽는 방식이 아닌, **인덱스를 역순으로 스캔하여 첫 번째 레코드만 읽는 것이 효율적**
- 즉, 쿼리가 인덱스를 **사용하는 시점에 인덱스를 읽는 방향(정순, 역순)에 따라 오름차순 또는 내림차순 정렬 효과**를 얻을 수 있음

### ✅ 내림차순 인덱스

- **내림차순 인덱스 : 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스**
(오름차순은 **작은 값**의 ~)
- **인덱스 정순 스캔 : (인덱스 키의 크고 작음에 관계없이) 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔**
    
    (인덱스 역순 스캔은 ~ **오른쪽 페이지부터 왼쪽**으로 스캔)
    
- 역순 정렬 쿼리가 정순 정렬 쿼리보다 시간이 더 걸림 → **인덱스 역순 스캔이 느림**
- 즉, 오름차순 인덱스+역순 스캔보다는 **내림차순 인덱스+정순 스캔을 하는 것이 더 효율적**임
