## Chapter 8-1: 인덱스 관련 질문지

### 1. 이미 변형된 값은 B-Tree의 장점을 이용할 수 없다.

8.3.2.4: 인덱스 키 검색에서 
`이미 변형된 값은 B-Tree 인덱스에 존재하는 값이 아니기에, 함수나 연산 수행 결과로 정렬/검색하는 작업은 B-Tree의 장점을 이용할 수 없다`
라고 하였는데, `이미 변형된 값`이 의미하는 종류에는 무엇이 있을까?

**정리**

이미 변형된 값이란 인덱스 컬럼에 함수나 연산을 적용한 결과를 의미한다. 예시를 들면
```
// 함수 적용:
SUBSTRING(name, 1, 3) - 문자열 자르기
UPPER(email) - 대소문자 변환
DATE_FORMAT(created_at, '%Y-%m') - 날짜 포맷 변경
CONCAT(first_name, last_name) - 문자열 결합

// 연산 적용:
salary * 1.1 - 산술 연산
price + tax - 컬럼 간 연산
year - 1 - 상수와의 연산
```
인데, B-Tree 인덱스는 원본 값으로 정렬되어 있기에, 변형된 값으론 인덱스의 정렬 순서를 활용할 수 없다는 것
    
### 2. 인덱스는 선택도가 높을 수록 검색 대상이 줄어든다.

8.3.3.3: 선택도(기수성)에서
`인덱스는 선택도가 높을 수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리가 가능해진다.`
라고 하였는데, 왜 각각이 유니크할 수록 검색 대상이 줄어들까?

**정리**

`선택도(Selectivity)가 높다 = 유니크한 값이 많다 = 중복이 적다`
예를 들어 이해해보자.
```
// 선택도가 낮은 경우 (성별):
전체 100만 건 중 '남성' 검색 -> 약 50만 건 반환
인덱스로 50만 건을 찾아도 여전히 많은 데이터 처리 필요

// 선택도가 높은 경우 (주민등록번호):
전체 100만 건 중 특정 주민번호 검색 -> 1건 반환
인덱스로 정확히 1건만 찾아서 처리
```
선택도가 높을수록 조건에 일치하는 레코드 수가 적어지므로, 검색해야 할 대상이 줄어들어 빠른 처리가 가능해진다. 
인덱스의 핵심은 **전체 데이터 중 일부만 빠르게 찾기**인데, 선택도가 높아야 이 **일부**가 작아진다는 개념.

### 3. 인덱스의 크기는 테이블의 크기보다 작으므로?
8.3.4.2: 인덱스 풀 스캔에서
`일반적으로 인덱스의 크기는 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것 보다는 인덱스만 읽는 것이 효율적이다.`
라고 하였는데, `인덱스의 크기는 테이블의 크기보다 작으므로`? 
테이블 자체를 조건에 따라 정렬한 것이 인덱스 아닌가? 전체 개수는 같을텐데 크기가 왜 작다하는가?

**정리**

개수가 아니라 용량(바이트) 측면에서의 크기를 말하는 것이었다..
행 개수는 같지만, 디스크에서 읽어야 할 데이터 용량이 인덱스가 훨씬 작기에 효율적인 것