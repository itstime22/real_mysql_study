### Q1. InnoDB 에서 LRU 리스트의 Young/Old 영역 비율을 5:3으로 설정한 이유는 뭘까?
- 62.5% Young 영역, 37.5% Old 영역 채 -> 자주 접근되는 데이터는 오래 유지하고, 한 번만 읽히는 데이터는 빨리 내보내기 위한 최적화된 비율
- reference : https://dev.mysql.com/doc/refman/8.4/en/innodb-performance-midpoint_insertion.html

---

### Q2. 포그라운드 스레드는 MySQL 엔진에서만 실행되고, 백그라운드 스레드는 스토리지 엔진에서만 실행되는 건지 궁금합니다.
- 포그라운드 스레드는 MySQL엔진, 스토리지 엔진 양쪽에서 실행됨 (스토리지 엔진에서 캐시를 가져올 때 포그라운드 스레드가 사용됨)
- 백그라운드 스레드는 스토리지 엔진에서 디스크에서 데이터를 가져와야할 떄 실행됨

> 즉, 데이터가 캐시 hit이면 포그라운드 스레드에서 처리, miss면 백그라운드 스레드에서 처리 (데이터를 디스크에서 가져와야함)

---

### Q3. MySQL은 프로세스 기반이 아닌 스레드 기반으로 동작할까?
- 컨텍스트 스위칭에서 장점이 있어 스레드 사용
- 컨텍스트 스위칭 -> 프로세스의 오버헤드가 큼
- 멀티 스레드 -> 동기화만 잘 할 수 잇다면 성능이 좋음
- RDBMS는 I/O 연산이 있으므로 멀티 스레드 기반에서 사용됨

---

### Q4. 하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 MySQL 엔진 영역에서 처리되는지 아니면 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 한다.
- 핸들러 API가 스토리지 엔진에서 데이터를 가져오는 손발이 되어줌 -> 핸들러 API가 하위 작업을 처리하기 

---

### Q5. 빠른 성능을 위해 사용되던 쿼리 캐시가 동시 처리 성능 저하 문제로 인하여 MySQL 8.0에서는 제거되었는데 현재는 어떤 방식으로 캐싱이 이루어지나요?
- 쿼리 캐싱 : 쿼리에 대한 결과를 캐싱 -> 동일한 쿼리에 대한 캐싱
- InnoDB 버퍼 풀 : 쿼리를 분석한 후 해당하는 레코드에 대한 캐싱 
- postgre : {쿼리, 데이터}까지 view에 작성함