# 02_설치와 설정 & 03_사용자 및 권한

---

## 02_설치와 설정

### MySQL 시스템 변수 확인

MySQL 시스템 변수 확인 : `show global variables;`

> `basedir`, `join_buffer_size`,  `auto_increment_increment`같은 전역 설정 값 존재.
MySQL 8.0 기준 대략 570개 정도 존재한다.
>

### 글로벌 변수와 세션 변수

**글로벌 변수**

- 주로 MySQL 서버 자체에 관련된 설정인 경우가 많다.

  InnoDB 버퍼 풀 크기(`inno_db_buffer_pool_size`), MyISAM 키 캐시 크기(`key_buffer_size`) 대표적

  > InnoDB는 **MySQL과 MariaDB에서 사용하는 스토리지 엔진**(Storage Engine)으로,
  트랜잭션 지원, 행 단위 잠금(Row-level locking), 외래 키(Foreign Key) 지원 등의 특징을 가짐
  >

  > MyISAM은 **MySQL 관계형 데이터베이스 관리시스템 5.5 버전 이전의 기본 스토리지 엔진**
  >

  > **InnoDB** : **성능**적인 측면 / **MyISAM** : **속도**적인 측면
  [https://velog.io/@akfls221/InnoDB-vs-MyIsam-세기대결](https://velog.io/@akfls221/InnoDB-vs-MyIsam-%EC%84%B8%EA%B8%B0%EB%8C%80%EA%B2%B0)
>
- 서버가 가동중인 상태에서 변경 가능 여부에 따라 **동적 변수**와 **정적 변수**로 구분
- `max_connections` 값 같은 동적 변수는 `SET GLOBAL` 수정 뿐만 아니라, 설정 파일에도 적용이 필요한데,
  나중에 이를 잊는 경우가 존재하여, 8.0 이상에서 `SET PERSIST` 명령어가 도입되었다.

## 03_사용자 및 권한

### 사용자 식별

> 단순히 사용자의 아이디 뿐 아니라, 접속중인 IP도 확인한다. Role의 개념으로 권한을 묶어서 관리한다.
EX) `svc_id`@`127.0.0.1` -> **``` (역 따옴표)**가 식별자를 감싸는 따옴표 역할을 한다.
>
- 만약 모든 외부 컴퓨터에서 접속 가능한 사용자 계정을 생성하고 싶다면, 호스트부를 `%`로 대체하면 된다.
- 호스트 부가 겹치는 여러 계정의 경우, 범위가 가장 작은 계정이 항상 먼저 선택된다.
- 내장된 계정 4개가 존재한다. → `root` 빼고는 삭제되면 안된다.
    - `root`@`localhost`
    - `mysql.sys`@`localhost` - 기본 내장 sys  스키마의 객체의 DEFINER로 사용
    - `mysql.session`@`localhost` - MySQL 플러그인이 서버로 접근할 때 사용
    - `mysql.infoschema`@`localhost` - information_schema에 정의된 뷰의 DEFINER로 사용

### 계정 생성: `CREATE USER`

> 인증 방식, 비밀번호, 비밀번호 관련 옵션 등의 설정 가능
>

# 04_아키텍처

---

## 4.1. MySQL 엔진 아키텍처

### MySQL 서버의 구성

- **MySQL 엔진**: 머리 역할
    - 커넥션 핸들러: 클라이언트 접속 및 쿼리 요청 처리
    - SQL 인터페이스
    - SQL 파서/전처리기
    - SQL 옵티마이저: 쿼리의 최적화된 실행
    - 캐시 & 버퍼
- **스토리지 엔진**: 손발 역할
    - InnoDB 스토리지 엔진, MyISAM 스토리지 엔진 등
    - MySQL 엔진과 달리 여러 개를 동시에 사용 가능
- **핸들러 API**
    - MySQL 엔진에서 스토리지 엔진에 쓰기 또는 읽기 요청 == 핸들러 요청
    - 이때 사용되는 API를 핸들러 API라 한다.

### MySQL 스레딩 구조

- MySQL 서버는 프로세스 기반이 아닌 **스레드 기반으로 작동**
- 크게 Foreground 스레드와 Background 스레드로 구분 가능
- 실행중인 스레드 목록은 performance_schema DB의 threads 테이블을 통해 확인 가능
    - 여러 스레드가 동일 작업을 병렬 처리중 일 경우 동일한 이름의 스레드가 존재할 수 있다.
    - `thread/sql/one_connection` 스레드가 실제 사용자 요청을 처리하는 포그라운드 스레드

### 포그라운드 스레드 (Client Thread)

**생명 주기**

- 서버에 접속된 클라이언트의 수 만큼 존재
- 클라이언트 사용자가 작업을 마치고 커넥션 종료 시 스레드 캐시로 되돌아간다.
- 이미 스레드 캐시에 일정 개수 이상 대기 중인 스레드가 있다면 스레드를 넣지 않고 종료시킨다.

**데이터 처리**

- 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져온다.
- 버퍼나 캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 읽어와서 작업 처리
- MyISAM의 경우 포그라운드 스레드가 디스크 쓰기 작업 진행
- InnoDB에서는 데이터 버퍼나 캐시까지만 포그라운드가 처리, 버퍼에서 디스크는 백그라운드가 처리

### 백그라운드 스레드

**InnoDB에서의 다양한 처리**

- 인서트 버퍼를 병합
- **로그를 디스크로 기록**
- **InnoDB 버퍼 풀의 데이터를 디스크에 기록**
- 데이터를 버퍼로 읽어옴
- 잠금이나 데드락을 모니터링

### 메모리 할당 및 사용 구조

**글로벌 메모리 영역**

- 테이블 캐시, InnoDB 버퍼 풀 등
- 클라이언트 스레드 수와 무관하게 하나의 메모리 공간 할당. 필요에 따라 여러 개

**로컬 메모리 영역**

- 정렬 버퍼, 조인 버퍼, 네트워크 버퍼 등
- 세션 메모리 영역, 클라이언트 메모리 영역 이라고도 함
- 클라이언트 스레드가 쿼리 처리를 위해 사용하는 메모리 영역
- 각 클라이언트 스레드별로 독립적으로 할당되어 절대 공유되지 않음

### 플러그인 스토리지 엔진 모델

- 스토리지 엔진, 검색어 파서, 인증 형식 등 많은 부분을 플러그인 형태로 개발하여 사용 가능

### 컴포넌트

- 플러그인 아키텍처는 몇몇 단점이 존재한다.
    - 플러그인 끼리는 통신 불가능한 문제
    - MySQL 서버의 변수나 함수를 직접 호출하여 안전하지 않음 (캡슐화 X)
    - 상호 의존 관계 설정이 불가하여 초기화가 어려움
- MySQL 8.0 부터 기존의 플러그인 아키텍처 대체를 위해 컴포넌트 아키텍처 지원

### 쿼리 실행 구조

![](https://user-images.githubusercontent.com/27190617/212525871-285d45ec-175f-4796-ab53-77c1105e0f1e.png)

1. 쿼리 파서
    - 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어내는 작업
    - 쿼리 문법의 기본 문법 오류는 이 과정에서 발견된다.
2. 전처리기
    - 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인
    - 토큰 내부 테이블/칼럼 이름의 존재 여부나 객체 접근 권한 등을 확인
    - 실제 존재하지 않거나 권한 없는 개체의 토큰은 이 단계에서 걸러진다.
3. 옵티마이저
    - 사용자 요청 쿼리 문장을 저렴한 비용을 가장 빠르게 처리할지를 결정하는 역할
    - DBMS의 두뇌 역할
4. 실행 엔진
    - 만들어진 계획에 따라, 각 핸들러에게 요청하여 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할 수행
5. 핸들러 (스토리지 엔진)
    - MySQL 서버의 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 저장/읽어오는 역할 수행
    - 스토리지 엔진을 의미하며, 무슨 테이블을 조작하냐에 따라 MyISAM 또는 InnoDB가 사용된다.

### 쿼리 캐시

- SQL 실행 결과를 메모리에 캐시하여, 동일 쿼리 실행 시 즉시 결과 반환
- 하지만 테이블 데이터 변경 시 캐시에서 관련 데이터가 삭제되어야 했기에, 심각한 동시 처리 성능 저하
- 이로 인해 MySQL 8.0 이후 기능에서 제거되었다.

### 스레드 풀

- 내부적으로 사용자 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 하여 서버의 자원 소모를 줄이는 것이 목적
- Percona Server의 스레드 풀은 기본적으로 CPU 코어의 개수만큼 스레드 그룹 생성

  > Percona Server: MySQL과 MariaDB를 기반으로 하는 오픈 소스 데이터베이스 소프트웨어
>
- 스레드 그룹의 모든 스레드가 일을 처리하고 있다면, 스레드 풀은 새로운 작업 스레드(Worker Thread)를 추가할지, 기존 작업 스레드의 처리 완료를 기다릴지 판단해야한다.
- 새로운 요청은 `thread_pool_stall_limit` 만큼 기다린 후 기존 스레드를 기다린 후 처리된다.

### 메타데이터 저장

- MySQL 5.7 까지는 테이블 구조를 FRM 파일에 저장하고 일부 스토어드 프로그램도 파일 기반으로 관리
- 하지만 트랜잭션을 지원하지 않기에 일관성이 깨지는 문제가 발생 (데이터베이스나 테이블이 깨졌다.)
- MySQL 8.0 부터는 테이블 구조 정보나 스토어드 프로그램의 정보를 InnoDB의 테이블에 저장
    - 사용자가 임의로 수정할 수 없도록 접근이 제한된다.

## 4.2. InnoDB 스토리지 엔진 아키텍처

### Primary Key에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 PK를 기준으로 클러스터링 되어 저장
- 모든 세컨더리 인덱스는 레코드 주소 대신 PK 값을 논리적인 주소로 사용한다.
- MyISAM 스토리지 엔진의 경우 클러스터링 키를 지원하지 않고, 물리적 주소를 사용한다.

### 외래 키 지원

- 외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하며, MyISAM이나 Memory에서는 지원 X

### MVCC (Multi Version Concurrency Control)

> 잠금을 사용하지 않는 일관된 읽기 제공 목적
>

- e.g., `UPDATE member SET m_area=’경기’ WHERE m_id=12;`
- UPDATE 쿼리 실행 시, 커밋 여부에 관계 없이 InnoDB 버퍼 풀은 새로운 값인 ‘경기’로 업데이트 된다.
- 디스크의 데이터 파일의 업데이트 여부는 시점에 따라 다를 수 있다.
- 커밋이나 롤백 이전, 사용자 조회 시 타겟은 MySQL 서버의 시스템 변수에 설정된 격리 수준에 따라 다르다.
- 격리 수준 `READ_UNCOMMITED`의 경우 InnoDB 버퍼 풀의 데이터를 반환
- `READ_COMMITED`나 그 이상의 경우 변경 이전의 언두 영역 데이터 반환

![](https://velog.velcdn.com/images/juy4556/post/c2333bfa-6038-4d95-ad34-2bb74e089adb/image.png)

### 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)

- INSERT와 연결되지 않은 순수한 SELECT 작업은 항상 잠금을 대기하지 않고 바로 실행된다.
- 오랜 시간동안 활성 상태인 트랜잭션은 언두 로그를 삭제하지 않고 유지하기에, 이로인해 서버가 느려지거나 문제가 발생하기도 한다. 가능한 빠른 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋다.

### 자동 데드락 감지

- InnoDB 스토리지 엔진은 내부적으로 데드락 체크를 위해 잠금 대기 목록을 그래프(Wait-for List)로 관리
- 교착 상태에 빠진 트랜잭션들을 찾아 그중 하나를 강제 종료한다.
- 강제 종료 트랜잭션 선택 기준은 트랜잭션의 언두 로그 양이며, 적게 가진 트랜잭션이 롤백 대상이 된다.
- `inno_db_table_locks` 시스템 변수 활성화 시 InnoDB 스토리지 엔진 내부 레코드 뿐만 아니라, 테이블 레벨의 잠금까지 감지할 수 있게 되기에 활성화가 권장된다.
- 동시 처리 스레드가 매우 많은 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모하여 서비스에 악영향을 끼칠 수 있다.
- `innodb_deadlock_detect` 시스템 변수 `OFF` 설정을 통해 데드락 감지 스레드를 작동 해제할 수 있다.
    - 하지만 이 경우 누군가가 중재를 하지 않기에 데드락 발생 시 무한정 대기하게 된다.
    - `innodb_lock_wait_timeout` 시스템 변수 활성화로 일정 시간 이후 요청을 실패처리 시킨다.
    - 단위는 초 단위로, 기본 값은 50초 이나 더 낮은 시간으로 변경을 권장한다.
- PK 또는 세컨더리 인덱스 기반 동시성 처리 요구 서비스가 있다면, 데드락 감지 스레드를 비활성화하여 성능 비교를 진행하는 것도 좋은 접근 방식이다.

### 자동화된 장애 복구

- InnoDB 테이블이 손상되는 경우는 상당히 희박하지만, 하드웨어 손상 등에 의해 일어날 수 있다.
- 대부분의 손상은 인덱스에서 발생하여, ALTER TABLE 또는 데이터 덤프 및 재 적재만으로 해결 가능하다.
- `inno_db_force_recovery` 설정값이 0이 아닌 복구 모드에서는 SELECT 이외의 쿼리는 수행할 수 없다.
- 설정값 1로 부터 시작하여, 6까지 늘려가며 재시작하는 방식으로 해결을 진행한다.
- 값이 커질수록 심각한 상황이기에 데이터 손실 가능성은 커지고 복구 가능성은 작아진다.

### InnoDB 버퍼 풀

- InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 데이터 파일이나 인덱스 정보를 캐시해두는 공간
- 쓰기 작업을 지연시켜 일괄 처리 가능하게하는 버퍼 역할 수행
- 버퍼풀의 크기는 상황에 따라 다른데, 8GB 미만 메모리의 경우 50% 정도만 설정하여 OS와 MySQL 서버, 다른 프로그램을 위해 메모리를 남기고, 그 이상이라면 50%에서 늘려가며 최적점을 찾는다.
- `innodb_buffer_pool_size` 시스템 변수로 크기를 설정할 수 있다.
- 버퍼 풀의 크기 변경은 Critical 한 작업이며, 특히 줄이는 작업은 영향도가 매우크다.
- 서버가 한산한 경우 진행하며, 128MB 단위로 처리됨을 인지하자.

### 버퍼 풀의 구조

- InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 조각으로 쪼개어 관리한다.
- 관리를 위해 LRU 리스트, 플러시 리스트, 프리 리스트, 3개의 자료 구조를 관리한다.
- 프리 리스트는 채워지지 않은 페이지 목록이다.
- LRU 리스트는 New 와 Old 서브리스트로 5:3 비율 구분되어, 새로운 페이지는 5/8 지점에 추가한다.
    - 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 버퍼 풀 메모리에 유지하여 디스크 읽기를 최소화 하는것이 LRU 리스트 관리의 목적이다.

### 버퍼 풀과 리두 로그

![](https://velog.velcdn.com/images/semi-cloud/post/4d453df2-8fe4-475b-9a5c-929cb32236b2/image.png)

- 단순히 버퍼 풀의 메모리 공간 증가는 캐시에만 영향을 준다.
- 쓰기 버퍼링 기능까지 향상을 위해서는 InnoDB 버퍼 풀과 리두 로그 간 관계를 먼저 이해해야 한다.
- 리두 로그 공간은 계속 순환되어 재사용되지만 로그 포지션(LSN, Log Sequence Number)은 계속 증가된 값을 가진다.
- 마지막 체크포인트 LSN과 마지막 리두 로그 엔트리의 LSN 차이가 체크포인트 에이지이고, 이는 활성 리두 로그 공간의 크기와 같다.
- 체크포인트 발생 시 체크포인트 LSN보다 작은 LSN 값을 가진 리두 로그 엔트리와 더티 페이지는 모두 디스트로 동기화된다.
- InnoDB 버퍼 풀이 커도, 리두 로그 파일 크기가 작으면 허용 가능한 더티 페이지 크기가 작아져 쓰기 버퍼링 이점을 크게 얻지 못한다.
- 리두 로그 파일 크기만 커도, 체크포인트 에이지가 너무 커져 급작스러운 쓰기가 발생할 수 있다.
    - 쓰기 폭발(Disk IO Burst)
- 당연하겠지만 두 공간 크기를 잘 조절하여 최적값을 선택하는 것이 좋다.

### 버퍼 풀 플러시

- InnoDB 스토리지 엔진은 성능 상 악영향 없이 디스크 동기화를 위해 2개의 플러시 기능을 백그라운드로 실행한다.

**플러시 리스트(Flush_list) 플러시**

- 주기적으로 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화 진행

**LRU 리스트(LRU_list) 플러시**

- LRU 리스트에서 사용 빈도가 낮은 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 생성
- LRU 리스트의 끝부분 부터 탐색하여, 더티 페이지는 동기화, 클린 페이지는 프리 리스트로 이동

### 버퍼 풀 상태 백업 및 복구

- InnoDB 버퍼 풀은 쿼리 성능에 매우 밀접하게 관련됨
- 서비스 재 시작 시 쿼리 처리 성능이 1/10도 안되는 경우가 대부분이다. (워밍업이 안되어있기에)
- 이 이유로, MySQL 5.6 부터 버퍼 풀 덤프 및 적재 기능도 지원한다.