[**노션 정리**](https://sweltering-diadem-a68.notion.site/2a655b9ff8dd8088811bc898970e11cb?pvs=74)
# 아키텍처

**MySQL 서버 = MySQL 엔진 + 스토리지 엔진**

- MySQL 엔진: 머리 역할
- 스토리지 엔진:  손발 역할

# MySQL 엔진 아키텍처

## 📌 MySQL의 전체 구조

- (일반 상용 RDBMS처럼) 대부분의 **프로그래밍 언어**로부터 **접근 방법**을 모두 지원
    - JDBC, ODBC 등 표준 드라이버 제공
    - C/C++, 자바, 파이썬 등 모든 언어로 MySQL 서버에서 쿼리 사용 지원

### ✅ **MySQL 엔진**

**요청된 SQL 문장을 분석하거나 최적화** 

- 구성요소
    - **커넥션 핸들러**: 클라이언트로부터의 접속 및 쿼리 요청 처리
    - **SQL 파서 및 전처리기:** 쿼리 문장 분석 및 검증
    - **SQL 옵티마이저**: 쿼리 실행 최적화
    - **캐시/버퍼**: 데이터를 메모리에 임시 저장
- MySQL은 표준 SQL(ANSI SQL) 문법 지원 → 작성된 타 DBMS와 호환됨

### ✅ **스토리지 엔진**

**실제 데이터를 디스크 스토리지에 저장하거나 읽어오기**

- 구성요소
    - **InnoDB**
    - **MyISAM**
    - **Memory**
- MySQL 서버에서 **스토리지 엔진은 여러 개 동시에** 사용 가능 (MySQL 엔진은 하나)
- 테이블이 사용할 스토리지 엔진을 지정 → 해당 테이블의 **모든 읽기 및 변경 작업**은 **정의된 스토리지 엔진이 처리**
    - ex) `CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB` (InnoDB 엔진 사용)
        
        → test_table에 INSERT, UPDATE 등 작업 발생 시, InnoDB 스토리지 엔진이 처리 담당
        
- 각 스토리지 엔진은 **성능 향상**을 위해 **키 캐시(MyISAM 스토리지 엔진)**나  **InnoDB 버퍼 풀(InnoDB 스토리지 엔진)**과 같은 기능 내장

### ✅ 핸들러 API

- **핸들러 요청**: MySQL 엔진의 **쿼리 실행기에서 데이터를 쓰거나 읽어야** 할 때, 각 **스토리지 엔진에 쓰기 또는 읽기를 요청**
- **핸들러 API**: 핸들러 요청 시 사용되는 API
- 핸들러 API로 스토리지 엔진이 MySQL 엔진과 데이터 주고받는 것

## 📌 MySQL 스레딩 구조

MySQL은 (프로세스 기반이 아닌) **스레드 기반**으로 작동

- **포그라운드(Foreground) 스레드**와 **백그라운드(Background) 스레드**로 구분
- 전통적인 스레드 모델 설명 (스레드 풀 모델은 추후에 설명)

### ✅ 포그라운드 스레드(클라이언트 스레드 = 사용자 스레드)

- 최소 MySQL 서버에 접속된 클라이언트 수만큼 존재
- 스레드 흐름 이해
    1. 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 되돌아감 
    2. 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료 
    3. 일정 개수의 스레드만 스레드 캐시에 존재하게 됨
- 주로 **각 클라이언트 사용자가 요청하는 쿼리 문장을 처리**
    - 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오기
    - (버퍼나 캐시에 없는 경우) 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어오기
    - MyISAM: 디스크 쓰기 작업까지 포그라운드가 담당
    - InnoDB: 데이터 버퍼나 캐시까지만 포그라운드가 담당 (디스크 쓰기는 백그라운드가 담당)

### ✅ 백그라운드 스레드

- MyISAM은 해당 사항 없음
- **InnoDB**가 백그라운드로 처리하는 작업
    - 인서트 버퍼를 병합하는 스레드
    - **로그를 디스크로 기록하는 스레드 (로그 쓰레드)**
    - **InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드 (쓰기 쓰레드)**
    - 데이터를 버퍼로 읽어 오는 스레드
    - 잠금이나 데드락을 모니터링하는 스레드
- 읽기 스레드는 주로 클라이언트 스레드에서 처리되기에 많이 설정할 필요 X
- 쓰기 작업은 지연(버퍼링) 가능, 읽기 작업은 절대 지연 X
- 보통 **쓰기 작업을 버퍼링해서 일괄 처리** → 데이터 변경 시 디스크에 완전히 저장될 때까지 기다릴 필요 X
    - 주의) MyISAM은 사용자 스레드가 쓰기 작업까지 함께 처리 (버퍼링 기능 X)

## 📌 메모리 할당 및 사용 구조

메모리 공간 → **글로벌 메모리 영역**과 **로컬 메모리 영역**으로 구분

### ✅ 글로벌 메모리 영역

- 메모리 공간은 **운영체제로부터 할당**
    - 운영체제에 따라 메모리 할당 방식에 차이
- (클라이언트 스레드의 수와 무관하게) **하나의 메모리 공간만 할당**
    - 필요에 따라 2개 이상의 메모리 공간 할당
    - 모든 스레드에 의해 공유
- 대표 예시
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼

### ✅ 로컬 메모리 영역 (세션 메모리 영역 = 클라이언트 메모리 영역)

- **클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역**
    
    ex) 커넥션 버퍼, 정렬(Sort) 버퍼 
    
- 로컬 메모리는 **각 클라이언트 스레드 별로 독립적으로 할당**되고 **공유되어 사용 X**
- 적절한 메모리 공간을 설정 중요
- 각 쿼리의 용도별로 **필요할 때만 공간이 할당**되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을 수 있음 ex) 정렬 버퍼나 조인 버퍼
- 대표 예시
    - 정렬 버퍼(소트 버퍼)
    - 조인 버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼
    

## 📌 플러그인 스토리지 엔진 모델

- MySQL의 핵심적인 구조적 특징
- **스토리지 엔진을 자신이 개발한 엔진으로 교체** 가능
- MySQL 엔진이 스토리지 엔진을 조정하기 위해 **핸들러** 사용
    
    (핸들러: 어떤 기능을 호출하기 위해 사용하는 운전대와 같은 역할을 하는 객체)
    
- **하나의 쿼리 작업은 여러 하위 작업**으로 나뉨 → 각 하위 작업이 MySQL 엔진 영역에서 처리되는지 아니면 스토리지 엔진 영역에서 처리되는지 구분 필요
- 스토리지 엔진 뿐만 아니라 **다양한 기능을 플러그인 형태로 지원**
    
    ex) 인증, 전문 검색 파서, 쿼리 재작성 등
    

## 📌 컴포넌트

- 기존의 플러그인 아키텍처를 대체하기 위해 **컴포넌트 아키텍처가 지원 (단점 보완 해줌)**
- **플러그인의 단점**
    - 플러그인끼리는 통신 불가능
    - 변수나 함수를 직접 호출 → 캡슐화 X
    - 상호 의존관계를 설정 불가능

## 📌 쿼리 실행 구조

### ✅ 쿼리 파서

- **쿼리 문장을 토큰으로 분리하여 트리 형태의 구조**로 만드는 작업
- 토큰: MySQL이 인식할 수 있는 최소 단위의 어휘나 기호  ex) SELECT, FROM
- 이 과정에서 쿼리의 **문법 오류 발견**

### ✅ 전처리기

- **파서 트리의 구조적인 문제점 확인**
- 각 토큰을 개체(함수, 컬럼)로 매핑해 **해당 객체의 존재 여부와 객체의 접근 권한 등을 확인**

### ✅ 옵티마이저

- 쿼리 문장을 **저렴한 비용으로 가장 빠르게 처리할지 결정**
- **즉, 최적화 = 옵티마이저가 더 나은 선택을 할 수 있게 유도**

### ✅ 실행 엔진

- **만들어진 계획 대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결**
- 최종 결과를 사용자에게 전달

### ✅ 핸들러 (스토리지 엔진)

- **실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오기**
- MyISAM 테이블 조작 → MyISAM 스토리지 엔진이 핸들러
- InnoDB 테이블 조작 → InnoDB 스토리지 엔진이 핸들러

## 📌 쿼리 캐시

- **빠른 성능**을 위해 기존에 사용
- 테이블의 데이터가 변경되면  변경된 테이블과 관련된 결과 모두 삭제 필요 → **동시 처리 성능 저하 유발**
- 현재 사용 X

## 📌 스레드 풀

- 사용자의 **요청을 처리하는 스레드 개수를 줄이기** → MySQL 서버의 CPU가 **제한된 개수의 스레드 처리에만 집중** → 서버의 **자원 소모 줄이기 (스레드 풀의 목적)**
- 실제 서비스에서 눈에 띄는 성능 향상 X (오히려 쿼리 처리가 더 느려질 수도)
- 제한된 수의 스레드만으로 CPU가 처리될 수 있도록 적절하게 조절하면 CPU 프로세서 친화도도 높이고, 오버헤드를 낮추기 가능

## 📌 트랜잭션 지원 메타데이터

- MySQL 초반 버전에서는 메타데이터를 **파일 기반**으로 관리 → **비정상적 종료 시, 일관성 깨짐**
- MySQL 8.0 버전부터는 **메타데이터(시스템 테이블, 데이터 딕셔너리)를 트랜잭션 기반의 InnoDB 테이블에 저장** → **비정상적 종료되더라도 스키마 변경이 완전한 성공 또는 완전한 실패**

# 2. InnoDB 스토리지 엔진 아키텍처

- **MySQL 스토리지 엔진 중, 가장 대표적인 엔진**
- 거의 유일하게 **레코드 기반의 잠금**을 제공 → **높은 동시성 처리 가능, 안정적이며 성능이 뛰어남**

## 📌 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 **프라이머리 키를 기준으로 클러스터링 (정렬) →** 프라이머리 키 값의 순서대로 디스크에 저장
- **프라이머리 키 = 클러스터링 인덱스** → **프라이머리 키를 이용한 레인지 스캔 빨리 처리** 가능 → 쿼리의 실행 계획에서 다른 보조 인덱스보다 **프라이머리 키가 선택될 확률이 높음**
- MyISAM 스토리지 엔진에서는 클러스터링 키를 지원 X
    
    

## 📌 외래 키 지원

- InnoDB 스토리지 엔진 레벨에서 지원하는 기능 (MyISAM, MEMORY 테이블에서는 사용 X)
- 데이터베이스 서버 운영의 불편함 때문에 서비스용 DB에서는 생성하지 않는 경우가 많음
- **개발 환경의 DB에서는 좋은 가이드 역할**
- InnoDB에서는 외래 키에 주의 필요 (부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성 필요하고, 변경 시에는 부모 테이블이나 자식 테이블에 데이터 유무 체크 필요함 → 잠금이 여러 테이블로 전파되고 그로인해 데드락 발생 가능)
- (수동으로 데이터를 적재하거나 스키마 변경 등의) 관리 작업이 **실패한 경우** → **`foreign_key_checks` 시스템 변수를 OFF로 설정**하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈추기 가능 → **훨씬 빠르게 처리 가능** (처리 후, 다시 외래 키 체크 기능 활성화 필요)

## 📌 MVCC(Multi Version Concurrency Control)

- **잠금을 사용하지 않는 일관된 읽기를 제공하는 기능**
- InnoDB는 **언두 로그(Undo log)**를 이용해 MVCC을 구현
- ex) 격리 수준이 `READ_COMMITTED`인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블의 데이터 변경 처리
- MySQL에 설정된 **격리 수준**에 따라 COMMIT이나 ROLLBACK이 되지 않은 상태에서 레코드 조회 시, **조회하는 영역이 다름**
- 격리 수준이 `READ_UNCOMMITTED`인 경우 → **InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환** (커밋과 관계없이 변경된 상태의 데이터를 반환)
- 격리 수준이 `READ_COMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE`인 경우 → 커밋되지 않았기 때문에 **변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환**

## 📌 잠금 없는 일관된 읽기

- MVCC 기술을 이용해 **잠금을 걸지 않고 읽기 작업을 수행**
- 격리 수준이 `SERIALIZABLE`이 아닌 `READ_UNCOMMITTED`나 `READ_COMMITTED`, `REPEATABLE_READ` 수준인 경우, 순수한 읽기 작업은 항상 잠금을 대기하지 않고 바로 실행
- 트랜잭션 오랜 시간 동안 활성 상태 (일관된 읽기를 위해 언두 로그 유지) → MySQL 서버가 느려지거나 문제가 발생 → 즉, **트랜잭션이 시작됐다면 가능한 빨리 롤백이나 커밋을 통해 트랜잭션 완료해야됨**

## 📌 자동 데드락 감지

- InnoDB 스토리지 엔진은 **잠금이 교착 상태에 빠지지 않았는지 체크**하기 위해 **잠금 대기 목록을 그래프 형태로 관리**
- **데드락 감지 스레드가 주기적으로 잠금 대기 그래프 검사** → **교착 상태인 트랜잭션 찾아서 강제 종료**
- 트랜잭션 강제 종료 선택 기준: **가장 언두 로그 레코드를 적게 가진 트랜잭션 종료**
- **`innodb_table_locks`** 활성화 하는 것이 좋음 →  InnoDB 스토리지 **엔진 내부의 레코드 잠금 뿐만 아니라 테이블 레벨의 잠금까지 감지 가능**
- 동시 처리 스레드가 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 **데드락 감지 스레드가 느려려짐** →`innodb_deadlock_detect`를 `OFF` 로 설정하면 데드락 감지 스레드 작동하지 않아 해결 가능
    - 주의) 기본값(50초)보다 훨씬 낮은 시간으로 변경해서 사용 권장

## 📌 InnoDB 버퍼 풀

- InnoDB 스토리지 엔진에서의 가장 핵심
- **디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간**
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 **버퍼 역할**도 수행

### ✅ 버퍼 풀의 크기 설정

- **운영체제와 각 클라이언트 스레드가 사용할 메모리 고려해서 설정**
- InnoDB 버퍼 풀의 크기를 **적절히 작은 값으로 설정하고 상황에 따라 증가시키는 것이 최적**
    1. 회사에서 **이미 MySQL 서버를 사용** → 그 서버의 **메모리 설정을 기준**으로 InnoDB 버퍼 풀의 크기 조정
    2. **처음으로 MySQL 서버**를 준비 
        1. 운영체제의 전체 메모리 공간이 8GB 미만 → 50% 정도만 버퍼 풀로 설정하고 나머지 메모리 공간은 MySQL 서버, 운영체제, 다른 프로그램이 사용할 수 있는 공간으로 확보
        2. 전체 메모리 공간이 8GB  이상 → 50%에서 시작해서 올리면서 최적점 찾기 
        3. 50GB 이상 → 대략 15GB~30GB를 (운영체제, 다른 응용 프로그램 용으로) 남겨두고 나머지를 InnoDB 버퍼 풀로 할당

### ✅ 버퍼 풀의 구조

- **버퍼풀(메모리 공간)을 페이지 크기의 조각으로 쪼개어** InnoDB 스토리지 엔진이 데이터를 필요로 할 때 **해당 데이터 페이지를 읽어서 각 조각에 저장**
- 버퍼 풀의 페이지 크기 조각을 관리하기 위해 **LRU 리스트, 플러시 리스트, 프리 리스트**라는 3개의 자료구조를 관리
    - **프리(Free) 리스트:** 실제 사용자 데이터로 채워지지 않은 **비어 있는 페이지들의 목록**
    - **LRU(Least Recently Used) 리스트**: **New 서브리스트(LRU) + Old 서브리스트(MRU)**
        - 자주 사용 → MLU 영역에서 계속 살아남음
        - 거의 사용되지 않음 → LRU끝으로 밀려나 버퍼 풀에서 제거
    - **플러시(Flush) 리스트**: **더티 페이지**(디스크로 동기화되지 않은 데이터를 가진 페이지)의 **페이지 목록 관리**
        - 읽은 상태 그대로 전혀 변경 X → 플러시 리스트에 관리 X
        - 한 번 변경이 가해진 데이터 페이지 → 플러시 리스트에 관리 / 특정 시점이 되면 디스크로 기록

### ✅ 버퍼 풀과 리두 로그

- **데이터베이스 성능 향상**을 위한 버퍼 풀의 핵심 용도
    - **데이터 캐시**: **버퍼 풀의 메모리 공간**을 늘려 데이터 캐시 기능 향상
    - **쓰기 버퍼링**: **리두 파일의 총 크기를 늘려** 쓰기 버퍼링 향상
- **더티 페이지**: 메모리에서 변경되었지만 아직 디스크에 쓰이지 않은 페이지
- **리두 로그:** 서버 다운에 대비한 데이터 변경 기록
    - 리두 파일의 크기를 적절하게 조절하면 체크포인트가 덜 발생하고 버퍼링에 여유 생김
    - ex) 100GB 이하의 서버에서는 리두 로그 파일의 전체 크기를 5~10GB로 선택하고 늘려가며 최적값 찾기

### ✅ 버퍼 풀 플러시

- **더티 페이지를 디스크로 동기화**
    - 성능에 악영향 없이 디스크에 동기화하기 위해 플러시 리스트 플러시와 LRU 리스트 플러시를 백그라운드로 실행
    - MySQL 8.0 버전부터는 개선되었기에 성능 문제 발생 안할 시, 조정 필요 X

### ✅ 버퍼 풀 상태 백업 및 복구

- 셧다운 후 **서비스를 재시작** → **쿼리 처리 성능이 많이 느려짐** (버퍼 풀에 쿼리가 사용할 데이터가 준비되지 않았기 때문 = 워밍업 X)
- **워밍업(Warming Up)**: 디스크의 데이터가 버퍼 풀에 적재되어 있는 상태 (잘 워밍업된 상태에서는 몇십 배의 쿼리 처리 속도)
- **버프 풀 덤프 및 적재**: MySQL 5.6 버전부터는 재시작 필요 시 **미리 버퍼 풀의 상태를 백업 및 복구** 가능
    - 백업(덤프): `mysql> SET GLOBAL innodb_buffer_pool_dump_now=ON;`
    - 복구(적재): `mysql> SET GLOBAL innodb_buffer_pool_load_now=ON;`
- 자동 백업 및 복구를 하려면 `innodb_buffer_pool_dump_at_shutdown`과 `innodb_buffer_pool_load_at_startup` 설정을 MySQL 서버의 설정 파일에 넣기

### ✅ 버퍼 풀의 적재 내용 확인

- InnoDB 버퍼 풀이 클 경우 **테이블 조회에 상당히 큰 부하 발생** → 서비스 쿼리가 많이 느려짐
- MySQL 8.0에서는 `information_schema` 데이터베이스에 **`innodb_cached_indexes` 테이블을 추가하여 해결** → 테이블의 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재되어 있는지 확인 가능
