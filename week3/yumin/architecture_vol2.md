[**노션 정리**](https://sweltering-diadem-a68.notion.site/2-2ad55b9ff8dd8064a50fca355c94d818)
# 아키텍처2

# 2. InnoDB 스토리지 엔진 아키텍처

## 📌 Double Write Buffer

- 문제 상황: InnoDB 스토리지 엔진의 리두 로그는 리두 로그 공간 낭비를 막기 위해 페이지의 변경된 내용만 기록 → **페이지의 일부만 기록 되는 현상(파셜 페이지, 톤 페이지)** 발생 → 하드웨어 오작동 또는 시스템 비정상 종료 유발
- 해결: **Double - Write 기법 이용**
    - 더티 페이지를 디스크로 플러시 할 때, 데이터 파일에 변경 내용을 기록하기 전에 더티 페이지를 묶어서 한번의 디스크 쓰기로 **시스템 테이블스페이스의 Double Write 버퍼에 기록 (이중 장치)**
    - 만약 일부만 기록되는 문제 발생 시 (**톤 페이지 발생**),  **Double Write 버퍼에서 복사하여 데이터 파일의 페이지로 적어주기**
- 묶어서 사용하는 이유: HDD에서는 한번의 순차 디스크 쓰기를 진행하기에 성능적으로 좋음 (SSD의 경우, 랜덤 IO의 비용이 비싸지 않기에 순차 IO가 부담이 될 수 있음)

## 📌 언두 로그

- **언두 로그**: DML로 **데이터가 변경되기 전에 백업 해둔 데이터**
- 사용
    1. **트랜잭션 보장** → 트랜잭션의 **롤백** 대비용 (롤백 명령을 내렸을 때, 언두 로그를 데이터 복구에 사용)
    2. **격리 수준 보장** → **격리 수준**을 유지하면서 **높은 동시성** 제공 (다른 트랜잭션이 데이터를 수정하고 있을 때 영향을 받지 않고, 언두 로그의 이전 데이터 읽기)
- **MySQL 5.5 버전까지의 문제**: 언두 로그의 사용 공간이 **한번 늘어나면** 서버를 새로 구축하지 않는 한 **줄일 수 없음** → 누적된 언두 로그가 디스크 사용량을 증가시키고, 스캔/복사할 양을 늘려 **쿼리의 성능 저하 유발**
- **MySQL 8.0 버전에서의 해결**: 언두 로그를 돌아가면서 순차적으로 사용하여 **디스크 공간을 줄이고, 필요한 시점에 사용 공간을 자동으로 줄여줌**
- **모니터링**: 활성 상태의 트랜잭션이 장시간 유지되는 것은 성능 상 좋지 않기에 **언두 로그의 급증 여부를 모니터링**

### ✅ **언두 테이블스페이스 관리**

- **언두 테이블스페이스: 언두 로그가 저장된는 공간**
- **버전 별 차이**
    - MySQL 5.6 이전: 언두 로그가 모두 시스템 테이블스페이스에 저장 (**확장에 한계**가 있음)
    - MySQL 8.0:  **별도 로그 파일에 기록**되도록 개선 / 새로운 **언두 테이블 스페이스를 동적으로 추가하고 삭제** 가능
        - **언두 테이블스페이스 TRUNCATE**: 언두 테이블스페이스 파일의 **불필요하거나 과도한 공간을 운영체제로 반납**
            - 자동, 수동 두가지 방법으로  TRUNCATE 가능
            

## 📌 체인지 버퍼

- **체인지 버퍼**: 인덱스를 변경할 때 많은 자원을 소모하기에 **즉시 실행하지 않고 저장해두는 임시 공간**
    
    → **임시 공간에 저장해두고 바로 사용자에게 결과를 반환**하여 성능 향상
    
- **유니크 인덱스**는 **반드시 중복 여부를 체크해야 하기에** 체인지 버퍼 사용 불가 (어차피 중복 여부를 위해 바로 디스크를 읽어야 하므로 **사용할 필요 x**)
- **버퍼링**:  체인지 버퍼에 임시로 저장된 인덱스 변경 작업은 **머지 스레드(백그라운드 스레드)에 의해 병합**
    - MySQL 5.5 이전: INSERT 작업만 버퍼링이 가능
    - MySQL 8.0: I**NSERT, DELETE, UPDATE 작업도 버퍼링 가능 → 체인지 버퍼**
- **설정**: innodb_change_buffering 시스템 변수로 버퍼링 설정 가능 (사용할 수 있는 메모리 공간도 설정 가능 - 최대 50%)
    - INSERT, UPDATE가 빈번한 경우, 버퍼의 크기를 늘려주는 것이 좋음
    

## 📌 리두 로그 및 로그 버퍼

- **리두 로그: ACID 중 D(영속성)을 지키기 위한 안전장치**
    
    → 서버가 비정상적 종료되더라도 **데이터 파일에 기록되지 못한 데이터를 잃지 않도록 안전장치**
    
    - 대부분 데이터베이스 서버는 변경 내용을 먼저 로그로 기록하는데 DB는 쓰기보다 **읽기 성능을 고려하기에 쓰기는 랜덤 엑세스 필요** → **쓰기 비용이 낮은 리두 로그로 기록하여 성능 향상**
- **로그 버퍼**: 리두 로그의 쓰기 횟수도 줄여 성능을 더 향상시키기 위해 **리두 로그를 디스크에 바로 쓰지 않고 로그 버퍼에 모아두고 한번에 보내기**
- 데이터 복구 원리
    1. **커밋됐지만 데이터 파일에 기록되지 않은 데이터** → **리두 로그에 저장된 데이터를 데이터 파일에 다시 복사**
    2. **롤백됐지만 데이터 파일에 기록된 데이터** → 리두 로그는 해결할 수 없고, **변경되기 전 데이터를 가진 언두 로그에 기록된 데이터로 복사** (이 경우, 리두 로그는 상태 확인에 쓰임)

### ✅ **리두 로그 아카이빙**

- **리두 로그 아카이빙: MySQL 8.0부터 도입된 백업을 돕는 기능**
    - 문제 상황: 로그 파일을 복사할 때, (백업이 실시간 리두 로그를 따라갈 수 없어) 파일이 **이미 덮어씌워진 경우 로그를 복사할 수 없어 백업 실패**
    - 해결책: 리두 로그 아카이빙을 활성화하여 **덮어쓰이기 전에 아카이빙할 디렉토리에 저장**
- 백업 스크립트에서 수동으로 활성화/비활성화 가능

### ✅ **리두 로그 활성화 및 비활성화**

- 리두 로그는 MySQL 서버의 비정상적 종료 시의 복구를 위해 **항상 활성화**
- MySQL 8.0부터는 **비활성화**를 지원하여 **대량의 데이터를 한번에 적재하는 경우 적재 시간을 단축 가능**
    
    → 이 경우, **복구가 불가능**하기에 주의
    

 

## 📌 어댑티브 해시 인덱스

- **어댑티브 해시 인덱스**: (일반적으로 생각하는 사용자가 생성하는 B-Tree와 같은 인덱스가 아니라) InnoDB 스토리지 엔진이 **사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인메모리 인덱스**
    - 문제점: 일반적인 B-Tree 인덱스는 검색을 빠르게 처리하나, 동시에 몇천 개의 스레드로 실행 시 결국 **쿼리의 성능 저하가 발생**
    - 해결: **자주 읽히는 데이터 페이지의 키 값으로 어댑티브 해시 인덱스**를 만들고 필요할 때 해당 인덱스로 **즉시 찾아가기** → B-Tree의 루프부터 리프까지의 검색 비용이 사라지기에 **쿼리 성능 향상**
- 해시 인덱스: **인덱스 키 값, 데이터 페이지 주소 쌍**으로 관리
    - **인덱스 키 값**은 실제로는 **B-Tree 인덱스 ID, B-Tree 인덱스 실제 키 값**으로 구성
        
         → **하나의 어댑티브 해시 인덱스가 여러 B-Tree 인덱스의 단축키 역할** 해줌
        
    - 어댑티드 해시 인덱스는 **버퍼 풀**에 올려진 데이터 페이지에서만 존재
- 어댑티브 해시 인덱스의 **상황에 따른 성능**
    - **성능 향상에 도움이 되지 않는 상황**
        1. 디스크 읽기가 많은 경우
        2. 특정 패턴의 쿼리가 많은 경우 (조인, LIKE)
        3. 매우 큰 데이터를 가진 테이블을 폭넓게 읽는 경우
        
        → 확실한 것은 데이터 페이지를 **디스크에서 읽어오는 경우가 많은 데이터베이스 서버**에서는 도움 X
        
    - **성능 향상에 도움이 되는 상황**
        1. 디스크의 데이터가 버퍼 풀 크기와 비슷한 경우
        2. 동등 조건 검색(=, IN)이 많은 경우
        3. 쿼리가 일부 데이터에만 집중하는 경우 
        

## 📌 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

- MySQL 8.0: **MyISAM 스토리지 엔진, MEMORY 스토리지 엔진**은 경쟁력 X (차후 없어질 것)
- **InnoDB 스토리지 엔진**을 지원하도록 대부분 교체

# 3. MyISAM 스토리지 엔진 아키텍처

## 📌 키 캐시

- **키 캐시(키 버퍼): 인덱스 전용 캐시**
    - InnoDB의 **버퍼 풀**과 비슷한 역할
    - 인덱스의 디스크 **쓰기 작업에 대해서만 부분적인 버퍼링**
- **키 캐시 히트율** = 100 - (key_reads / key_reads_requests * 100)
    
    → 키 캐시를 이용한 쿼리의 비율을 99%이상으로 유지 권장 (낮다면 키 캐시 공간 확보 고려)
    

## 📌 운영체제의 캐시 및 버퍼

- MyISAM의 한계: 디스크 I/O를 해결하기 위한 **캐시/버퍼링 기능 없음** → 즉, **데이터 읽기/쓰기 작업은 항상 운영체제에 의존**
- MyISAM 테이블을 주로 사용할 경우, **운영체제의 메모리 관리 필요**

## 📌 데이터 파일과 프라이머리 키(인덱스) 구조

- **MyISAM의 데이터 저장방식**: **클러스터링 없이 데이터 파일이 힙 공간처럼 활용**
    - 프라이머리 키 값과 무관하게 **INSERT되는 순서대로 데이터 파일에 저장**
    - **InnoDB**는 **프라이머리 키에 의해서 클러스터링하여 저장** (PK 순서대로 데이터를 정렬해서 저장)
- ROWID(주소값) 저장 방식
    - 가변 길이
    - 고정 길이
    

# 4. MySQL 로그 파일

로그 파일을 통해 MySQL의 상태나 부하를 일이키는 원인 파악 가능 

→ **로그 파일을 자세히 확인하는 습관 중요!**

## 📌 에러 로그 파일

- **에러 로그 파일:** MySQL이 실행되는 도중, **발생하는 에러나 경고 메시지가 출력되는 로그 파일**
- 위치: **설정 파일(my.conf)의 log_error 파라미터**에 지정된 경로에 생성
    
    → 별도 지정 안한 경우 **.err이라는 확장자**
    

### ✅ 시작 관련 정보성 및 에러 메시지

- 다시 시작할 때, MySQL 서버 작성 기동 메시지 확인 (’mysqld: ready for connection’)
- 새로 변경이나 추가 시, 특별한 에러나 경고성 메시지가 없다면 정상적으로 적용된 것

### ✅ 비정상적 종료 시 복구 메시지

- 비정상적으로 종료되었을 때, 재시작하는 과정에서 **InnoDB가 데이터를 복구하는 작업**을 기록
- 복구 되지 못할 경우, 에러 메시지 출력하고 종료

### ✅ 쿼리 처리 문제 시 에러 메시지

- 쿼리가 실행되는 *도중*에 발생한 문제들을 기록
- 자주 에러 로그 검토 필요

### ✅ 비정상적 종료된 커넥션 메시지

- 네트워크 에러와 같은 비정상적으로 종료 시, 기록

### ✅ 모니터링 결과 메시지

- 모니터링 기능은 **사용 후에 꼭 비활성화 (에러 로그가 너무 커지기에)**

### ✅ MySQL 종료 메시지

- 종료된 이유 기록

## 📌 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)

- **제너럴 쿼리 로그: 서버에서 실행되는 모든 쿼리 기록**
    - 실행되기 전에 MySQL이 쿼리 요청을 받으면 **바로 기록**
    - 에러 발생 시에도 기록

## 📌 슬로우 쿼리 로그

- **슬로우 쿼리 로그: 느린 쿼리(long_query_time 시스템 변수에 설정된 시간 이상 소요) 모두 기록**
    - **어떤 쿼리가 문제의 쿼리인지 판단**하기 위해 사용
    - 쿼리가 정상적으로 실행이 완료돼야 슬로우 쿼리 로그에 기록
- 슬로우 쿼리 로그 분석: **로그 파일의 내용이 상당히 많기에 분석이 어려움**
    
    → **Percona Toolkit의 pt-query-digest 스크립트** 사용
