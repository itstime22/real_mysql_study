# 9.3 고급 최적화

## 9.3.1 옵티마이저 스위치 옵션

- 옵티마이저 스위치 옵션은 `optimizer_switch` 시스템 변수를 이용해서 제어한다.
- `optimizer_switch` 시스템 변수에는 여러 개의 옵션을 세트로 묶어서 설정하는 방식으로 사용한다.
- 각각의 옵티마이저 스위치 옵션은 default와 on, off 중에서 하나를 설정할 수 있는데, on으로 설정되면 해당 옵션을 활성화하고, off를 설정하면 해당 옵션을 비활성화한다. 그리고 default를 설정하면 기본값이 적용된다.
- 옵티마이저 스위치 옵션은 글로벌과 세션별 모두 설정할 수 있는 시스템 변수이므로 MySQL 서버 전체적으로 또는 현재 커넥션에 대해서만 설정할 수 있다.
- 또한 SET_VAR 옵티마이저 힌트를 이용해 현재 쿼리에만 설정할 수도 있다.

### 9.3.1.1 MRR과 배치 키 액세스(mrr & batched_key_access)

- MRR은 Multi-Range Read를 줄여서 부르는 이름인데, 매뉴얼에서는 DS-MRR(Disk Sweep Multi-Range Read)이라고도 한다.
- MySQL 서버에서 지금까지 지원하던 조인 방식은 **드라이빙 테이블의 레코드를 한 건 읽어서 드리븐 테이블의 일치하는 레코드를 찾아서 조인을 수행하는 것**이었다. 이를 **네스티드 루프 조인(Nested Loop Join)**이라고 한다.
- MySQL 서버의 내부 구조상 조인 처리는 MySQL 엔진이 처리하지만, 실제 레코드를 검색하고 읽는 부분은 스토리지 엔진이 담당한다.
- 이때 드라이빙 테이블의 레코드 건별로 드리븐 테이블의 레코드를 찾으면 **레코드를 찾고 읽는 스토리지 엔진에서는 아무런 최적화를 수행할 수 없다.**
- 이 같은 단점을 보완하기 위해 MySQL 서버는 조인 대상 테이블 중 하나로부터 레코드를 읽어서 **조인 버퍼에 버퍼링**한다.
    - 즉, **드라이빙 테이블의 레코드를 읽어서 드리븐 테이블과의 조인을 즉시 실행하지 않고 조인 대상을 버퍼링하는 것**이다.
- 조인 버퍼에 **레코드가 가득 차면 비로소 MySQL 엔진은 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청**한다.
- 이렇게 함으로써 스토리지 엔진은 읽어야 할 레코드들을 데이터 페이지에 정렬된 순서로 접근해서 디스크의 데이터 페이지 읽기를 최소화할 수 있는 것이다.
    - 이러한 읽기 방식을 MRR이라고 하며, MRR을 이용해서 실행되는 조인 방식을 BKA(Batched Key Access) 조인이라고 한다.
- BKA 조인 최적화는 기본적으로 비활성화돼 있는데, 이는 BKA 조인의 단점이 있기 때문이다.
    - 쿼리의 특성에 따라 BKA 조인이 큰 도움이 되는 경우도 있지만, BKA 조인을 사용하게 되면 부가적인 정렬 작업이 필요해지면서 오히려 성능에 안 좋은 영향을 미치는 경우도 있다.

### 9.3.1.2 블록 네스티드 루프 조인(block_nested_loop)

- MySQL 서버에서 사용되는 대부분의 조인은 네스티드 루프 조인인데, 조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 조인 방식이다.
- 네스티드 루프 조인과 블록 네스티드 루프 조인의 가장 큰 차이는 조인 버퍼가 사용되는지 여부와 조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인되느냐다.
- 조인 알고리즘에서 Block이라는 단어가 사용되면 조인용으로 별도의 버퍼가 사용됐다는 것을 의미하는데, 조인 쿼리의 실행 계획에서 Extra 칼럼에 `Using Join buffer`라는 문구가 표시되면 그 실행 계획은 조인 버퍼를 사용한다는 것을 의미한다.
- 조인은 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하면서 처리된다. 즉 드라이빙 테이블은 한 번에 쭉 읽지만, 드리븐 테이블은 여러 번 읽는다는 것을 의미한다.
- 만약 드리븐 테이블의 조인 조건이 인덱스를 이용할 수 없다면 드리븐 테이블에서 연결되는 레코드를 찾기 위해 풀 테이블 스캔을 해야 한다.
- 그래서 드리븐 테이블을 검색할 때 인덱스를 사용할 수 없는 쿼리는 상당히 느려지며, 옵티마이저는 최대한 드리븐 테이블의 검색이 인덱스를 사용할 수 있게 실행 계획을 수립한다.
- 그런데 어떤 방식으로도 드리븐 테이블의 풀 테이블 스캔을 피할 수 없다면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리한다.
- 이때 사용되는 메모리의 캐시를 조인 버퍼라고 한다.
- 조인 버퍼가 사용되는 쿼리에서는 조인의 순서가 거꾸로인 것처럼 실행된다. 드라이빙 테이블의 결과는 조인 버퍼에 담아두고, 드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 처리된다. 일반적으로 조인이 수행된 후 가져오는 결과는 드라이빙 테이블의 순서에 의해 결정되지만, 조인 버퍼가 사용되는 조인에서는 결과의 정렬 순서가 흐트러질 수 있음을 기억해야 한다. 참고로 MySQL 8.0.18 버전부터는 해시 조인 알고리즘이 도입됐으며, MySQL 8.0.20 버전부터는 블록 네스티드 루프 조인은 더 이상 사용되지 않고 해시 조인 알고리즘이 대체되어 사용된다.

### 9.3.1.3 인덱스 컨디션 푸시다운(index_condition_pushdown)

- MySQL 5.6 버전부터는 인덱스 컨디션 푸시다운이라는 기능이 도입됐다.
- 인덱스 범위 제한 조건으로 사용하지 못하는 조건이라 하더라도 인덱스에 포함된 칼럼의 조건이 있다면 모두 같이 모아서 스토리지 엔진으로 전달할 수 있게 핸들러 API가 개선된 것이다.
- 인덱스 컨디션 푸시다운이 활성화되면 실행 계획의 Extra 칼럼에 `Using index condition`이 출력된다.
- 인덱스 컨디션 푸시다운이 작동하지 않을 때는 인덱스를 통해 레코드를 읽고, 테이블의 레코드를 읽은 후 MySQL 엔진에서 나머지 조건을 검사하는 방식을 취한다.
- 만약 인덱스 범위 제한 조건에 일치하는 레코드는 많지만 최종적으로 필터링되는 레코드가 단 한 건이라면, 불필요한 테이블 읽기 작업이 매우 많이 발생하게 된다.
- 하지만 인덱스 컨디션 푸시다운 기능을 사용하면 스토리지 엔진 내에서 인덱스에 포함된 칼럼의 조건을 한 번 더 검사하여 꼭 필요한 레코드에 대해서만 테이블 읽기를 수행할 수 있게 된다.
- 이는 고도의 기술력을 필요로 하는 기능은 아니지만 쿼리의 성능이 몇 배에서 몇십 배 향상될 수도 있는 중요한 기능이다.

### 9.3.1.4 인덱스 확장(use_index_extensions)

- `use_index_extensions` 옵티마이저 옵션은 InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션이다.
- InnoDB 스토리지 엔진은 프라이머리 키를 클러스터링 키로 생성하므로 모든 세컨더리 인덱스는 리프 노드에 프라이머리 키 값을 가진다.
- 예전 MySQL 버전에서는 세컨더리 인덱스의 마지막에 자동 추가되는 프라이머리 키를 제대로 활용하지 못했지만, MySQL 서버가 업그레이드되면서 옵티마이저는 세컨더리 인덱스의 마지막에 프라이머리 키 칼럼이 숨어있다는 것을 인지하고 실행 계획을 수립하도록 개선됐다.
- 이를 통해 인덱스 구성 칼럼에 프라이머리 키 칼럼을 명시적으로 포함하지 않아도 해당 칼럼을 이용한 인덱스 레인지 스캔이나 정렬 작업에 인덱스를 활용할 수 있게 된다.

### 9.3.1.5 인덱스 머지(index_merge)

- 인덱스를 이용해 쿼리를 실행하는 경우, 대부분 옵티마이저는 테이블별로 하나의 인덱스만 사용하도록 실행 계획을 수립한다.
- 하지만 인덱스 머지 실행 계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리한다.
- 쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고 그 조건을 만족하는 레코드 건수가 많을 것으로 예상될 때 MySQL 서버는 인덱스 머지 실행 계획을 선택한다.
- 인덱스 머지 실행 계획은 결과의 병합 방식에 따라 index_merge_intersection, index_merge_sort_union, index_merge_union의 3가지 세부 실행 계획으로 나뉜다.

### 9.3.1.6 인덱스 머지 - 교집합(index_merge_intersection)

- 여러 개의 WHERE 조건을 가지고 있는데, 각각의 조건이 서로 다른 인덱스를 사용할 수 있고 각 인덱스를 통해 검색된 결과의 교집합만 반환하는 방식을 의미한다
- 실행 계획의 Extra 칼럼에 Using intersect라고 표시된다.
- 옵티마이저는 각각의 인덱스를 검색해 본 결과 두 조건 모두 상대적으로 많은 레코드를 가져와야 한다는 것을 알게 되었을 때, 각 인덱스를 검색해 두 결과의 교집합만 찾아서 반환하는 것이 효율적이라고 판단하여 이 방식을 선택한다.

### 9.3.1.7 인덱스 머지 - 합집합(index_merge_union)

- WHERE 절에 사용된 2개 이상의 조건이 각각의 인덱스를 사용하되 OR 연산자로 연결된 경우에 사용되는 최적화다.
- 실행 계획의 Extra 칼럼에 Using union이라고 표시된다.
    - 이는 각 인덱스의 검색 결과를 Union 알고리즘으로 병합했다는 것을 의미한다.
- MySQL 서버는 두 결과 집합에서 중복 레코드를 제거하기 위해 정렬 작업을 수행하지 않고, 각 결과가 프라이머리 키로 이미 정렬되어 있다는 점을 이용해 우선순위 큐(Priority Queue)를 사용하여 중복을 제거한다.

### 9.3.1.8 인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)

- 인덱스 머지 작업을 하는 도중에 결과의 정렬이 필요한 경우 MySQL 서버는 Sort union 알고리즘을 사용한다.
- 합집합 최적화(Using union)는 각 인덱스의 검색 결과가 프라이머리 키로 정렬된 경우에만 사용 가능하지만, 만약 결과가 프라이머리 키로 정렬되어 있지 않다면 MySQL 서버는 각 집합을 프라이머리 키로 정렬한 다음 중복 제거를 수행한다.
- 이 경우 실행 계획의 Extra 칼럼에 `Using sort_union` 문구가 표시된다.

### 9.3.1.9 세미 조인(semijoin)

- 다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지만 체크하는 형태의 쿼리를 세미 조인이라고 한다.
- MySQL 5.7 서버는 전통적으로 세미 조인 형태의 쿼리를 최적화하는 부분이 상당히 취약했다.
    - 세미 조인 최적화 기능이 없었을 때는 서브쿼리 부분을 먼저 실행하지 않고 메인 테이블을 풀 스캔하면서 한 건 한 건 서브쿼리의 조건에 일치하는지 비교하는 방식을 사용했기 때문에 성능이 매우 좋지 않았다.
- 세미 조인 형태의 쿼리와 안티 세미 조인 형태의 쿼리는 최적화 방법이 조금 차이가 있다.
    - 우선 서브쿼리가 비교 연산자나 IN 연산자로 연결된 세미 조인 쿼리에 대해 세미 조인 최적화, 인 투 이그지스트 최적화, 구체화 최적화를 적용할 수 있다.
    - 그리고 서브쿼리가 비교 연산자나 NOT IN 연산자로 연결된 안티 세미 조인 쿼리에 대해서는 인 투 이그지스트 최적화와 구체화 최적화 방법이 있다.
    - MySQL 8.0 버전부터는 세미 조인 쿼리의 성능을 개선하기 위해 테이블 풀 아웃, 중복 제거, 퍼스트 매치, 루스 스캔, 구체화 전략을 모아서 세미 조인 최적화라고 부른다.
    - 쿼리에 사용되는 테이블과 조인 조건의 특성에 따라 옵티마이저는 사용 가능한 전략들을 선별적으로 사용한다.

### 9.3.1.10 테이블 풀-아웃(Table Pull-out)

- 테이블 풀 아웃 최적화는 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화다.
- 이 최적화는 세미 조인 서브쿼리에서만 사용 가능하며 서브쿼리 부분이 유니크 인덱스나 프라이머리 키 룩업으로 결과가 1건인 경우에만 사용 가능하다.
- 테이블 풀 아웃 최적화가 사용됐는지는 실행 계획에서 해당 테이블들의 아이디 칼럼 값이 같은지 비교해보거나 쇼 워닝스 명령으로 옵티마이저가 재작성한 쿼리를 살펴봄으로써 확인할 수 있다.

### 9.3.1.11 퍼스트 매치(firstmatch)

- 퍼스트 매치 최적화 전략은 서브쿼리 형태의 세미 조인을 이그지스트 서브쿼리 형태로 튜닝한 것과 비슷한 방법으로 실행된다.
- 이 전략은 서브쿼리에서 하나의 레코드만 검색되면 더 이상의 검색을 멈추는 단축 실행 경로이기 때문에 서브쿼리가 참조하는 모든 아우터 테이블이 먼저 조인된 이후에 실행된다.
- 퍼스트 매치 최적화가 사용되면 실행 계획의 엑스트라 칼럼에 퍼스트매치 문구가 표시된다.
- 이 최적화는 상관 서브쿼리에서도 사용될 수 있지만 그룹 바이나 집합 함수가 사용된 서브쿼리에는 사용될 수 없다.

### 9.3.1.12 루스 스캔(loosescan)

- 루스 스캔은 인덱스를 사용하는 그룹 바이 최적화 방법의 루스 인덱스 스캔과 비슷한 읽기 방식을 사용한다.
- 서브쿼리 테이블을 드라이빙 테이블로 사용하여 루스 인덱스 스캔으로 유니크한 키 값만 읽어들여 아우터 테이블과 조인을 수행한다.
- 이 방식은 서브쿼리 부분이 루스 인덱스 스캔을 사용할 수 있는 조건이 갖춰져야 사용 가능하다.

### 9.3.1.13 구체화(Materialization)

- 구체화 최적화는 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화한다는 의미다.
- 구체화는 내부 임시 테이블을 생성한다는 것을 의미하며 서브쿼리 내에 그룹 바이 절이 있어도 이 전략을 사용할 수 있다.
- 다만 서브쿼리는 상관 서브쿼리가 아니어야 하며 그룹 바이나 집합 함수가 사용되어도 구체화를 사용할 수 있다.

### 9.3.1.14 중복 제거(Duplicated Weed-out)

- 중복 제거는 세미 조인 서브쿼리를 일반적인 이너 조인 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘이다.
- 조인된 결과를 임시 테이블에 저장한 후 프라이머리 키를 기준으로 중복을 제거하여 남은 레코드를 최종적으로 반환한다.
- 실행 계획에서는 스타트 템포러리와 엔드 템포러리 문구의 구간이 중복 제거 최적화의 처리 과정임을 나타낸다.
- 이 최적화는 서브쿼리가 상관 서브쿼리라도 사용할 수 있지만 그룹 바이나 집합 함수가 사용된 경우에는 사용할 수 없다.

### 9.3.1.15 컨디션 팬아웃(condition_fanout_filter)

- 조인을 실행할 때 테이블의 순서는 쿼리의 성능에 큰 영향을 미친다.
- 옵티마이저는 여러 테이블이 조인되는 경우 가능하면 일치하는 레코드 건수가 적은 순서대로 조인을 실행한다.
- 컨디션 팬아웃 필터 최적화를 활성화하면 옵티마이저는 인덱스를 사용할 수 있는 조건 이외의 나머지 조건에 대해서도 얼마나 조건을 충족할지를 고려하여 더 정교한 계산을 거쳐 실행 계획을 수립한다.
- 이는 웨어 조건절에 사용된 칼럼에 대해 인덱스가 있거나 히스토그램이 존재하는 경우 더욱 정확하게 예측할 수 있다.

### 9.3.1.16 파생 테이블 머지(derived_merge)

- 예전 버전의 MySQL 서버에서는 프롬 절에 사용된 서브쿼리는 먼저 실행해서 그 결과를 임시 테이블로 만든 다음 외부 쿼리 부분을 처리했다.
- 하지만 파생 테이블 머지 최적화가 도입되면서 파생 테이블로 만들어지는 서브쿼리를 외부 쿼리와 병합하여 서브쿼리 부분을 제거하는 최적화가 가능해졌다.
- 이를 통해 임시 테이블을 생성하고 다시 읽는 오버헤드를 줄일 수 있다. 다만 집계 함수, 윈도우 함수, 디스틴트, 그룹 바이, 해빙, 리밋, 유니온 등이 사용된 서브쿼리는 자동으로 병합될 수 없으므로 수동으로 병합하여 작성하는 것이 성능 향상에 도움이 될 수 있다.

### 9.3.1.17 인비저블 인덱스(use_invisible_indexes)

- MySQL 8.0 버전부터는 인덱스의 가용 상태를 제어할 수 있는 기능이 추가되었다.
- 인덱스를 삭제하지 않고도 옵티마이저가 해당 인덱스를 실행 계획 수립 시 검토하지 않도록 제어할 수 있다.
- 유즈 인비저블 인덱스 옵션을 온으로 설정하면 인비저블 상태의 인덱스도 옵티마이저가 볼 수 있게 설정할 수 있다.

### 9.3.1.18 스킵 스캔(skip_scan)

- 인덱스의 핵심은 값이 정렬되어 있다는 것이며 이로 인해 인덱스를 구성하는 칼럼의 순서가 매우 중요하다.
- 인덱스 스킵 스캔은 인덱스의 선행 칼럼이 조건절에 사용되지 않더라도 후행 칼럼의 조건만으로 인덱스를 이용한 쿼리 성능 개선이 가능하게 하는 최적화 기법이다.
- 옵티마이저는 인덱스의 선행 칼럼이 소수의 유니크한 값을 가질 때만 인덱스 스킵 스캔 최적화를 사용한다.