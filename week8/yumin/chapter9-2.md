# 9.3 고급 최적화

- MySQL 옵티마이저는 **통계 정보**와 **옵티마이저 옵션**을 결합해 실행 계획을 수립함.
- **옵티마이저 스위치**: MySQL 5.5부터 도입. 고급 최적화 기능의 활성화 여부를 제어.

## 9.3.1 옵티마이저 스위치 옵션 내용

> optimizer_switch 시스템 변수
여러 최적화 옵션을 세트로 묶어 제어 (default, on, off 설정 가능)
> 

**적용 범위 및 설정 방법**

1. **Global / Session 설정**
    
    `SET GLOBAL optimizer_switch='index_merge=on, ...';
    SET SESSION optimizer_switch='index_merge=on, ...';`
    
2. **Query 단위 설정 (Hint)**
    
    `SELECT /*+ SET_VAR(optimizer_switch='index_merge=on, ...') */ ...`
    

### 9.3.1.1 MRR과 배치 키 액세스 (`mrr` & `batched_key_access`)

- **기존 Nested Loop Join의 문제**: 드라이빙 테이블 레코드 건별로 드리븐 테이블을 찾음 → 스토리지 엔진에서 **Random I/O** 발생.
- **MRR (Multi-Range Read)**:
    - 드라이빙 테이블 레코드를 **조인 버퍼**에 가득 채운 뒤, **정렬**하여 스토리지 엔진에 한 번에 요청.
    - **효과**: 디스크 페이지 접근을 순차적으로 만들어 **Disk Seek 최소화**.
- **BKA (Batched Key Access) 조인**: MRR 기능을 조인에 응용한 방식.

### 9.3.1.2 블록 네스티드 루프 조인 (`block_nested_loop`)

- **특징**: **조인 버퍼(Join Buffer)** 사용
- **발생 조건**: 드리븐 테이블의 풀 테이블 스캔을 막을 수 없을 때 (인덱스 없을 때).
- **동작 원리**:
    1. 드라이빙 테이블 레코드를 메모리(조인 버퍼)에 캐싱.
    2. 드리븐 테이블을 스캔하며 버퍼와 조인.
    3. 결과적으로 드리븐 테이블의 반복 스캔 횟수를 획기적으로 줄임.
- **참고**: MySQL 8.0.20부터는 해시 조인(Hash Join)으로 대체됨.

### 9.3.1.3 인덱스 컨디션 푸시다운 (`index_condition_pushdown`)

- **개념**: 인덱스에 포함된 컬럼 조건이라면, **스토리지 엔진** 단계에서 미리 체크하도록 전달(Pushdown)하는 기능.
- **효과**:
    - **Off**: 인덱스 범위 조건만 엔진이 처리 → 나머지 조건은 MySQL 엔진이 레코드를 읽은 후 필터링 (불필요한 I/O 발생).
    - **On**: 인덱스에 포함된 모든 조건을 엔진이 체크 → 조건 불일치 시 읽기 생략 (I/O 급감).
- **결과**: 쿼리 성능이 몇 배에서 몇십 배 향상 가능.

### 9.3.1.4 인덱스 확장 (`use_index_extensions`)

- **InnoDB 특성**: 세컨더리 인덱스의 리프 노드는 논리적으로 **PK를 포함**하고 있음.
- **동작**: 옵티마이저가 **(세컨더리 인덱스 컬럼 + PK 컬럼)** 조합을 하나의 인덱스처럼 인식하여 실행 계획을 수립.
- **장점**: 별도 정렬이나 추가적인 인덱스 생성 없이 PK를 활용한 정렬/필터링 가능.

### 9.3.1.5 인덱스 머지 (`index_merge`)

- **기본**: 보통 테이블당 1개의 인덱스만 사용.
- **인덱스 머지**: 하나의 테이블에 **2개 이상의 인덱스**를 사용하고 결과를 병합.
- **발생 조건**: 서로 다른 인덱스를 사용하는 쿼리 조건이 있고, 각 조건의 결과 건수가 많을 때.
- **세부 방식**:
    1. `intersection`: 교집합 (AND)
    2. `sort_union`: 정렬 후 합집합 (OR)
    3. `union`: 합집합 (OR)

### 9.3.1.6 인덱스 머지 - 교집합 (`index_merge_intersection`)

`WHERE` 절에 2개 이상의 조건이 있고, 각 조건이 서로 다른 인덱스를 사용할 수 있을 때 발생.

- **실행 계획 표시:** `Extra` 칼럼에 `Using Intersect`라고 표시.
- **작동 방식:**
    1. 각각의 인덱스를 검색하여 조건에 맞는 레코드의 PK를 찾음.
    2. 두 결과 집합의 **교집합(Intersection)** 만 추출함.
    3. 최종적으로 교집합에 해당하는 레코드만 반환함.
- **발생 원인:** 옵티마이저가 각 조건을 단독으로 사용했을 때보다, 두 인덱스의 결과를 교집합 했을 때 읽어야 할 레코드 수가 현저히 줄어든다고 판단했기 때문.
- **주의사항:** 만약 `ix_firstname` 같은 세컨더리 인덱스가 이미 PK(`emp_no`)를 포함하고 있다면, 굳이 두 인덱스를 교집합 하는 것보다 `ix_firstname`만 사용하는 것이 더 효율적일 수 있음, 이 경우 `index_merge_intersection` 최적화를 비활성화하는 것을 고려

### 9.3.1.7 인덱스 머지 - 합집합 (`index_merge_union`)

`WHERE` 절의 조건들이 `OR` 연산자로 연결되어 있고, 각각 다른 인덱스를 탈 수 있을 때 사용되는 최적화

- **실행 계획 표시:** `type` 칼럼에 `index_merge`, `Extra` 칼럼에 `Using union`으로 표시
- **작동 방식:**
    1. 각 조건에 맞는 인덱스를 검색함.
    2. 검색된 결과들을 **Union 알고리즘**으로 병합.
    3. 각 인덱스의 결과는 PK 기준으로 정렬되어 있으므로, **우선순위 큐(Priority Queue)** 를 사용하여 효율적으로 중복을 제거하며 병합.
- **특징:** `OR` 연산자는 일반적으로 인덱스를 제대로 타지 못하면 풀 테이블 스캔을 유발하지만, 이 최적화를 통해 인덱스를 활용할 수 있게 됩니다.

### 9.3.1.8 인덱스 머지 - 정렬 후 합집합 (`index_merge_sort_union`)

`index_merge_union`과 유사하지만, 각 인덱스 검색 결과가 **PK로 정렬되어 있지 않은 경우**에 사용

- **실행 계획 표시:** `Extra` 칼럼에 `Using sort_union`으로 표시됨.
- **작동 방식:**
    1. 각 인덱스를 검색함.
    2. 결과 집합이 PK로 정렬되어 있지 않으므로, 우선순위 큐를 사용할 수 없음.
    3. 따라서 **각 집합을 먼저 PK로 정렬(Sort)**
    4. 그 후 중복 제거 및 병합을 수행함.

### 9.3.1.9 세미 조인 (`semijoin`)

세미 조인은 **다른 테이블과 실제 조인(데이터 결합)을 수행하지 않고, 단지 조건에 일치하는 레코드가 존재하는지만 체크**하는 쿼리 형태. 주로 서브쿼리가 사용된 쿼리에서 발생.

> 핵심: 메인 쿼리 테이블과 서브쿼리 결과 간의 존재 여부 확인
> 

### 1. 최적화 전략의 변화

과거에는 서브쿼리를 최적화하지 못해 메인 쿼리를 풀 스캔하며 서브쿼리를 반복 실행하는 비효율적인 방식을 사용했으나, 최근에는 다양한 최적화 전략이 도입.

### 2. 세미 조인 vs 안티 세미 조인

- **세미 조인 (`=`, `IN`):** `Table Pull-out`, `Duplicate Weed-out`, `First Match`, `Loose Scan`, `Materialization` 전략 사용.
- **안티 세미 조인 (`<>`, `NOT IN`):** `IN-to-EXISTS`, `Materialization` 전략 사용.

### 3. 주요 세미 조인 최적화 전략

옵티마이저는 상황에 따라 아래 전략 중 하나를 선택

- **Table Pull-out:** 서브쿼리를 조인으로 변환 (항상 성능 향상).
- **First Match:** `firstmatch` 옵션으로 제어.
- **Loose Scan:** `loosescan` 옵션으로 제어.
- **Duplicate Weed-out:** `materialization` 옵션으로 제어.
- **Materialization:** `materialization` 옵션으로 제어.

### 9.3.1.10 테이블 풀-아웃 (Table Pull-out)

세미 조인 최적화 중 가장 빈번하고 효과적인 방법으로, **서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어내어 조인 쿼리로 재작성**하는 기법

- **적용 조건:**
    - 세미 조인 서브쿼리여야 함.
    - 서브쿼리가 **유니크 인덱스나 PK 룩업**으로 결과가 1건임이 보장되어야 함.
- **특징 및 장점:**
    - 가능하다면 MySQL은 이 방식을 최우선으로 적용
    - 서브쿼리 자체가 사라지고 조인으로 변경되므로 성능이 우수
    - **"서브쿼리를 억지로 조인으로 바꿀 필요가 없다":** 과거 튜닝 가이드였던 '서브쿼리의 조인 변환'을 옵티마이저가 자동으로 수행해주기 때문에, 가독성 좋은 서브쿼리를 그대로 사용해도 무방

### 9.3.1.11 퍼스트 매치 (FirstMatch)

`IN(subquery)` 형태를 `EXISTS(subquery)` 로직과 유사하게 처리하는 전략. 가장 큰 특징은 **조건에 일치하는 레코드를 1건만 찾으면 더 이상 탐색하지 않고(Short-circuit) 멈춘다**는 점

- **작동 방식:**
    - 내부적으로 서브쿼리가 아닌 **조인(Join)** 형태로 실행 (실행 계획의 `id` 값이 모두 1로 동일함)
    - 아우터 테이블의 레코드에 대해 이너 테이블(서브쿼리 영역)에서 일치하는 값이 발견되는 즉시 스캔을 멈추고 결과를 반환
- **기존 `IN-to-EXISTS` 와의 차이점:**
    - **최적화 전파:** 조인 형태로 처리되므로 옵티마이저가 동등 조건을 자동 추가하는 등 최적화의 범위가 더 넓음
    - **유연성:** 서브쿼리의 모든 테이블이 아닌, 일부 테이블에 대해서만 선별적으로 최적화를 적용
- **제약 사항 및 특징:**
    - **상관 서브쿼리(Correlated Subquery)**에서도 사용 가능
    - `GROUP BY`나 집합 함수가 포함된 서브쿼리에는 적용 x
    - 실행 계획 `Extra` 칼럼에 `FirstMatch(table-N)`으로 표시

### 9.3.1.12 루스 스캔 (LooseScan)

인덱스의 정렬된 특성을 이용하여 불필요한 스캔을 건너뛰는 방식. `GROUP BY` 최적화의 '루스 인덱스 스캔'과 유사한 매커니즘.

- **작동 방식:**
    - 서브쿼리 테이블의 인덱스를 스캔하되, 중복된 키 값은 무시하고 유니크한 값만 읽어 아우터 테이블과 매칭
    - 예를 들어, `(dept_no, emp_no)`가 PK인 테이블에서 `dept_no`만 필요하다면, 각 그룹의 첫 번째 레코드만 읽고 나머지는 건너뜀
- **효과:** 서브쿼리 테이블의 레코드 수가 아무리 많아도, 인덱스의 유니크한 키(그룹) 개수만큼만 스캔하면 되므로 I/O가 획기적으로 줄어듬
- **설정:** `optimizer_switch`의 `loosescan` 옵션으로 제어

### 9.3.1.13 구체화 (Materialization)

서브쿼리의 결과를 **내부 임시 테이블(Internal Temporary Table)**로 만들어(구체화하여) 최적화하는 방식

- **작동 방식:**
    1. 서브쿼리를 먼저 실행하여 그 결과를 임시 테이블에 저장. (이때 임시 테이블의 컬럼에는 인덱스가 생성되어 조인 성능을 높임)
    2. 아우터 테이블과 임시 테이블을 조인하여 최종 결과를 도출
- **특징:**
    - 실행 계획 `select_type`에 `MATERIALIZED`라고 표시
    - **`GROUP BY`나 집합 함수가 포함된 서브쿼리**에서도 사용할 수 있음 (FirstMatch와의 결정적 차이)
- **제약 사항:**
    - **상관 서브쿼리(Correlated Subquery)에는 사용할 수 없습니다.** (외부 쿼리에 의존하지 않는 독립적인 서브쿼리여야 함)
    - 내부 임시 테이블 생성 비용(메모리/디스크)이 발생

### 9.3.1.14 중복 제거 (Duplicate Weed-out)

세미 조인을 일반적인 `INNER JOIN`으로 변환하여 실행한 후, 마지막 단계에서 **중복된 레코드를 제거**하는 방식

- **작동 방식:**
    1. 서브쿼리 테이블과 아우터 테이블을 `INNER JOIN` 함 (이 과정에서 1:N 조인으로 인해 아우터 테이블의 레코드가 중복되어 늘어날 수 있음)
    2. 조인 결과에 대해 아우터 테이블의 PK를 기준으로 `GROUP BY`를 수행하는 것과 유사하게 중복을 제거
    3. 유니크해진 레코드를 반환
- **실행 계획 확인:**
    - `Extra` 칼럼에 `Duplicate Weed-out`이라고 명시되지 않음.
    - 대신 **`Start temporary`**와 **`End temporary`** 문구로 식별
- **특징:** `FirstMatch`나 `LooseScan` 등으로 처리하기 애매하거나, 일반 조인 성능이 나쁘지 않을 때 옵티마이저가 선택하는 전략

### 9.3.1.15 컨디션 팬아웃 (`condition_fanout_filter`)

조인 시 **테이블 순서(드라이빙 테이블 결정)**는 성능의 핵심임. 옵티마이저는 `filtered` 칼럼(조건 만족 레코드 비율)을 예측해 최적의 순서를 결정하려 함.

- **기능:** `WHERE` 절의 조건(인덱스 유무, 히스토그램 유무 등)을 분석하여 조건을 만족하는 레코드 건수를 정밀하게 예측.
- **효과:**
    - **비활성화 시:** 단순 인덱스 전체 개수 등을 기반으로 예측 (예: 233건 중 100% 만족 예측).
    - **활성화 시:** 실제 조건 필터링 비율을 계산하여 예측 (예: 233건 중 23.2%인 54건만 만족 예측).
- **의의:** 레코드 건수 예측 정확도가 높을수록, 적은 데이터를 읽는 방향으로 실행 계획 수립 가능. 단, 계산 오버헤드 발생 가능성 존재.

### 9.3.1.16 파생 테이블 머지 (`derived_merge`)

`FROM` 절에 사용된 서브쿼리(Derived Table) 처리 방식에 대한 최적화.

- **과거 방식:** 서브쿼리 결과를 **임시 테이블(메모리/디스크)**로 생성(`select_type=DERIVED`) 후 재조회함에 따라 오버헤드 발생.
- **최적화 방식 (`derived_merge`):** 파생 테이블을 외부 쿼리와 병합해 **서브쿼리를 제거**하고 일반적인 조인 형태로 변환함.
- **주의사항 (병합 불가 케이스):**
옵티마이저가 자동 병합 못하는 경우, **수동으로 외부 쿼리로 풀어써야** 성능 확보 가능.
    - 집계 함수 (`SUM`, `MIN` 등), `DISTINCT`, `GROUP BY`, `HAVING` 사용 시.
    - `LIMIT`, `UNION`, 사용자 변수 사용 시 등.

### 9.3.1.17 인비저블 인덱스 (`use_invisible_indexes`)

인덱스를 삭제하지 않고 **옵티마이저가 사용하지 못하게(Invisible)** 설정하는 기능.

- **사용법:** `ALTER TABLE ... ALTER INDEX ... INVISIBLE;`
- **용도:** 특정 인덱스 삭제 시 쿼리 성능에 미칠 영향을 미리 테스트할 때 유용함.

### 9.3.1.18 스킵 스캔 (`skip_scan`)

인덱스의 **선행 칼럼이 `WHERE` 조건절에 없어도** 인덱스 사용을 가능하게 하는 최적화.

- **작동 원리:** `(A, B)` 인덱스에서 `A` 조건 부재 시, `A` 칼럼의 유니크 값들을 조회해 마치 `A = '값'` 조건이 있는 것처럼 간주하고 `B` 칼럼 스캔.
- **조건:** 선행 칼럼(`A`)의 **카디널리티(유니크 값 개수)가 매우 적어야(소수)** 효율적임. 카디널리티가 높으면 오히려 비효율적.

### 9.3.1.19 해시 조인 (`hash_join`)

MySQL 8.0.18부터 도입, 8.0.20 이후 기존 **블록 네스티드 루프 조인(BNL)**을 완전히 대체한 조인 방식.

- **처리 방식:**
    1. **빌드(Build) 단계:** 레코드 수 적은 테이블을 골라 메모리에 **해시 테이블** 생성 (조인 버퍼 사용).
    2. **프로브(Probe) 단계:** 나머지 테이블 레코드를 읽으며 해시 테이블과 일치 여부 확인.
- **특징:**
    - **Best Throughput (처리량 중시):** 전체 데이터 처리 시간 단축 (분석형 쿼리에 유리).
    - **Latency (응답 속도):** 해시 테이블 생성 시간으로 인해 첫 레코드 반환 속도는 네스티드 루프 조인보다 느릴 수 있음.
    - 따라서 빠른 응답이 중요한 **웹 서비스(OLTP)에서는 여전히 인덱스 기반 네스티드 루프 조인 선호**.

### 9.3.1.20 인덱스 정렬 선호 (`prefer_ordering_index`)

옵티마이저가 `ORDER BY`나 `GROUP BY` 처리를 위해 인덱스 사용 가능 시, 해당 인덱스에 가중치를 부여하는 경향이 있음.

- **문제점:** 정렬을 위해 선택한 인덱스가 `WHERE` 조건 검색에는 비효율적일 수 있음 (정렬은 빠르나 스캔 데이터 과다).
- **해결:** 옵션을 `OFF`로 설정해 정렬 인덱스에 과도한 가중치를 주지 않도록 조정 가능.
