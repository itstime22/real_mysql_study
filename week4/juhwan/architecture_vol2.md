# MySQL 트랜잭션과 잠금 (Transaction & Locking)

> **핵심 메시지**  
> 트랜잭션은 데이터 정합성을 보장하고, 잠금은 동시성을 제어한다. MySQL/InnoDB는 MVCC와 Next-Key Lock으로 높은 동시성과 격리성을 동시에 달성한다.

---

## 1. 트랜잭션의 기본 개념

### 1.1 트랜잭션이란?

- **정의**: 여러 작업을 하나의 논리적 단위로 묶어 처리하는 기능
- **핵심 원칙**: **All or Nothing** - 모두 성공하거나 모두 실패하여 원상복구
- **목적**: 작업의 일부만 적용되는 현상(Partial Update) 방지

### 1.2 트랜잭션이 필요한 이유

- ✅ **데이터 정합성 보장**: 여러 작업이 원자적으로 처리됨
- ✅ **안전성 유지**: 비정상 종료나 오류 상황에서도 데이터 무결성 보장
- ✅ **동시성 충돌 방지**: 여러 사용자의 동시 작업으로 인한 데이터 불일치 방지

### 1.3 트랜잭션 상태 흐름

```
Active → Partially Committed → Committed
  ↓ (오류 발생)
Failed → Aborted → Rolled Back
```

---

## 2. ACID 속성

트랜잭션이 보장해야 하는 4가지 핵심 속성입니다.

| 속성 | 영문명 | 설명 | 구현 메커니즘 |
| --- | --- | --- | --- |
| **원자성** | Atomicity | 모두 성공하거나 모두 실패 | Undo Log |
| **일관성** | Consistency | 제약조건, 규칙 위반 없음 | 애플리케이션 로직 + DB 제약 |
| **격리성** | Isolation | 서로 다른 트랜잭션이 서로에게 영향을 주지 않음 | MVCC, Lock |
| **지속성** | Durability | 커밋된 데이터는 장애 이후에도 유지 | Redo Log |

---

## 3. 잠금(Lock)과 트랜잭션의 관계

### 3.1 잠금과 트랜잭션의 차이

| 구분 | 잠금(Lock) | 트랜잭션(Transaction) |
| --- | --- | --- |
| **목적** | 동시성 제어 | 데이터 정합성 보장 |
| **예시** | 하나의 레코드를 여러 커넥션에서 동시에 변경하지 못하도록 제어 | 여러 작업을 하나의 논리적 단위로 묶어 처리 |

### 3.2 주요 잠금 유형

#### Shared Lock (S-Lock, 읽기 잠금)
- 여러 트랜잭션이 동시에 획득 가능
- 다른 트랜잭션의 읽기는 허용, 쓰기는 차단

#### Exclusive Lock (X-Lock, 쓰기 잠금)
- 하나의 트랜잭션만 획득 가능
- 다른 트랜잭션의 읽기/쓰기 접근 모두 차단

---

## 4. MySQL 엔진 레벨 잠금

MySQL 엔진 레벨에서 제공하는 잠금 유형입니다.

| 잠금 유형 | 용도 | 특징 |
| --- | --- | --- |
| **글로벌 락** | 전체 MySQL 서버 인스턴스 잠금 | 백업 시 사용, 모든 테이블 읽기 전용 |
| **메타데이터 락** | 테이블 구조 변경 시 | DDL 실행 시 자동으로 획득, 스키마 변경 보호 |
| **네임드 락** | 임의의 문자열에 대한 잠금 | 데이터베이스 객체가 아닌 논리적 잠금, 클라이언트 간 동기화 |

---

## 5. 트랜잭션 격리 수준 (Isolation Levels)

여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하는 데이터를 어느 수준까지 볼 수 있게 허용할지를 결정하는 기준입니다.

### 5.1 격리 수준별 문제 현상

| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read | 특징 및 용도 |
| --- | --- | --- | --- | --- |
| **READ UNCOMMITTED** | ✅ 발생 | ✅ 발생 | ✅ 발생 | RDBMS 표준에서 인정하지 않을 정도로 정합성 문제 많음 |
| **READ COMMITTED** | ❌ 방지 | ✅ 발생 | ✅ 발생 | 오라클 기본값, 온라인 서비스에서 많이 선택 |
| **REPEATABLE READ** | ❌ 방지 | ❌ 방지 | ❌ 방지* | MySQL 기본값, InnoDB는 Next-Key Lock으로 Phantom Read도 방지 |
| **SERIALIZABLE** | ❌ 방지 | ❌ 방지 | ❌ 방지 | 가장 높은 격리 수준, 동시성 저하로 거의 사용 안 함 |

*InnoDB 스토리지 엔진에서는 Next-Key Lock을 통해 Phantom Read도 방지합니다.

### 5.2 격리 수준과 성능

- **일반적 원칙**: 격리 수준이 높아질수록 데이터 격리 정도는 높아지지만, 동시 처리 성능은 떨어집니다.
  - `READ COMMITTED`: 일반 웹 서비스에 적합
  - `REPEATABLE READ`: MySQL 기본값, 안정적이지만 Undo 로그 관리 필요
  - `SERIALIZABLE`: 거의 사용하지 않음 (성능 저하 심각)

---

## 6. MySQL/InnoDB의 격리성 구현 메커니즘

### 6.1 MVCC (Multi-Version Concurrency Control)

**핵심 개념**: 잠금을 사용하지 않는 일관된 읽기를 제공

**동작 원리**:
1. Undo Log에 이전 버전을 보관
2. 트랜잭션은 자신이 시작된 시점의 버전만 읽음
3. 읽기 작업이 쓰기 작업을 막지 않음 → **동시성 향상**


### 6.2 Next-Key Lock

**핵심 개념**: "레코드 + 갭(Gap)" 단위 잠금

**역할**:
- INSERT에 의한 Phantom Read 방지
- REPEATABLE READ 격리 수준에서도 Phantom Read를 완전히 차단

---

## 7. Auto-commit 모드

| 모드 | 설명 | 주의사항 |
| --- | --- | --- |
| **ON (기본)** | 모든 SQL이 독립적 트랜잭션 | DML 하나마다 트랜잭션 생성 → 성능 저하 가능 |
| **OFF** | BEGIN ~ COMMIT 사이 묶음 처리 | 명시적으로 트랜잭션 범위 관리 필요 |

---

## 8. 트랜잭션 설계 시 주의사항

애플리케이션에서 트랜잭션을 설계할 때 성능과 안정성을 위해 반드시 고려해야 할 핵심 원칙입니다.

### 8.1 트랜잭션 범위 최소화

- 프로그램 코드가 데이터베이스 커넥션을 가지고 있는 범위를 최소화
- 트랜잭션이 활성화되어 있는 프로그램의 범위를 최소화

### 8.2 외부 작업 배제

**반드시 트랜잭션에서 제외해야 할 작업**:
- 메일 전송
- FTP 파일 전송
- 원격 서버 통신
- 외부 API 호출

**이유**: 외부 서버와의 통신 불능 상태가 DBMS 서버에까지 위험을 전파할 수 있습니다.

### 8.3 커넥션 소유 시간 최소화

- 데이터베이스 커넥션은 개수가 제한적
- 커넥션을 소유하는 시간이 길어질수록 다른 프로그램이 대기해야 함
- 오랫동안 열린 트랜잭션은 성능에 최악의 영향을 미침

---

## 9. 트랜잭션 튜닝 포인트

### 9.1 너무 긴 트랜잭션 금지

**문제점**:
- Undo 로그 증가
- Purge 지연
- 성능 저하, 락 대기 증가

**해결책**: 트랜잭션 범위를 최소화하고, 불필요한 대기 시간 제거

### 9.2 격리 수준 상황별 최적 선택

| 격리 수준 | 권장 사용처 |
| --- | --- |
| **READ COMMITTED** | 일반 웹 서비스 |
| **REPEATABLE READ** | MySQL 기본값, 안정적 |
| **SERIALIZABLE** | 거의 사용하지 않음 |

### 9.3 적절한 인덱스 구성

- 불필요한 레코드 잠금 회피
- 인덱스를 통해 스캔 범위를 줄여 잠금 범위 최소화

### 9.4 일관된 커넥션 관리

- 커넥션 풀 적절히 활용
- 트랜잭션 종료 후 즉시 커넥션 반환
- 장시간 열린 트랜잭션 모니터링 및 개선
