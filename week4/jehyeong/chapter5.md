# 5.1. 트랜잭션

> MyISAM이나 MEMORY 스토리지 엔진은 트랜잭션을 지원하지 않는다. 어떤 문제들이 발생할까?
>

## 5.1.1 MySQL에서의 트랜잭션

**트랜잭션은 하나의 논리적 작업** 셋에 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 **100% 적용되거나 아무것도 적용되지 않아야 함을 보장**해주는것

부분 업데이트 현상 발생 시 실패한 쿼리로 인해 남은 레코드를 삭제하는 재처리 작업이 필요하게 된다.

## 5.1.2 주의사항

> 트랜잭션 또한 DBMS의 커넥션과 동일하게, 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.
프로그램 코드에서 트랜잭션의 범위를 최소화하라는 것이다.
>
- 특히 프로그램 코드에서 라인 수는 한 두줄이라 할지라도, 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다.
- DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠지는 경우가 빈번히 발생한다.

# 5.2 MySQL 엔진의 잠금

> MySQL의 잠금은 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나뉘며,
MySQL 엔진은 스토리지 엔진을 제외한 나머지 부분을 칭한다.
>
- MySQL 레벨의 잠근은 모든 스토리지 엔진에 영향을 미친다.
- 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지는 않는다.
- MySQL 엔진에서는 테이블 동기화를 위한 테이블 락 이외에도 테이블의 구조를 참그는 메타데이터 락(Metadata Lock)과 사용자가 필요에 맞게 사용하는 네임드 락(Named Lock) 기능도 제공한다.

## 5.2.1 글로벌 락

> MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.
>
- `FLUSH TABLES WITH READ LOCK` 명령으로 획득 가능하다.
    - 이 명령의 실행 전, 먼저 실행된 SQL과 그 트랜잭션이 완료될 때 까지 기다린다.
    - 이로인해 이전의 트랜잭션을 기다리다가 다른 모든 쿼리들이 실행되지 못하고 기다릴 수 있다.
- 한 세션에서 글로벌 락 획득 시 다른 세션에서 SELECT를 제외한 대부분의 DDL/DML 문장 실행 시
    - 글로벌 락이 해제 될 때 까지 대기 상태로 남는다.
- 영향을 미치는 범위는 MySQL 서버 전체이다.
- 보통 여러 데이터베이스에 존재하는 MyISAM이나 MEMORY 테이블에 대해 `mysqldump` 로 일관된 백업을 받아야 할 때는 글로벌 락을 사용한다.
- MySQL 8.0 부터는 `Xtrabackup`이나 `Enterprise Backup`과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입되었다.
    - 특정 세션에서 백업 락 획득 시 하위 요소들의 변경이 불가해진다.
        - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
        - REPAIR TABLE과 OPTIMIZE TABLE 명령
        - 사용자 관리 및 비밀번호 변경
    - 하지만 일반적인 테이블의 데이터 변경은 허용된다,

## 5.2.2 테이블 락

> 테이블 락은 개별 테이블 단위로 설정되는 잠금이며 묵시적/명식적으로 락이 획득된다.
>
- 명시적으로는 `LOCK TABLES table_name [ READ | WRITE ]` 명령으로 특정 테이블의 락을 획득 가능
    - UNLOCK TABLES 명령으로 잠금을 반납할 수 있다.
- 묵시적으로는 MyISAM이나 MEMORY에서 테이블 데이터 변경 쿼리 실행 시 받는다.
    - 데이터 변경 시점에 테이블에 잠금을 설정하고, 데이터 변경 후 즉시 잠금을 해제하는 방식
    - InnoDB 에선 스토리지 엔진 차원의 레코드 기반 잠금이 진행되어 묵시적 잠금은 설정되지 않는다.

## 5.2.3 네임드 락

> `GET_LOCK()` 함수를 이용해 임의의 문자열에 대해 잠금을 설정 가능하다.
>
- 이 잠금의 특징은 대상이 테이블이나 레코드, AUTO_INCREMENT 같은 DB 객체가 아니라는 것
    - 단순히 사용자가 지정한 문자열에 대해 획득하고 반납을 진행하는 잠금이다.
- 예를 들어, DB 서버 1대에 5대의 웹 서버가 접속해서 서비스하는 상황에서 5대의 웹 서버가 어떤 정보를 동기화해야 한다면?
    - 여러 클라이언트가 상호 동기화를 처리해야할 때 네임드 락을 통해 쉽게 해결이 가능하다.

```sql
SELECT GET_LOCK('mylock', 2)
SELECT IS_FREE_LOCK('mylock')
SELECT RELEASE_LOCK('mylock')
```

> 배치 프로그램처럼 한꺼번에 많은 레코드를 변경하는 쿼리는 자주 데드락의 원인이 되는데, 동일 데이터를 변경하거나 참조하는 프로그램 끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 간단히 해결된다.
>

## 5.2.4 메타데이터 락

> 데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금
>
- 명시적으로 획득하거나 해제가능한 락이 아니라, 자동으로 획득하는 잠금이다.

```sql
RENAME TABLE rank TO rank_backup;
RENAME TABLE rank_new TO rank;
```

위와 같은 분리 쿼리 실행 시, 아주 잠깐이지만 `rank` 테이블이 없는 시기가 생겨 이때 트랜잭션은 실패한다.

# 5.3 InnoDB 스토리지 엔진 잠금

> MySQL 제공 잠금과 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.
>
- 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서의 잠금 정보를 MySQL 서버에서 접근하기 까다로워졌다.
- 예전 버전의 MySQL 서버에서는 InnoDB 잠금 정보를 lock_monitor(`innodb_lock_monitor`)라는 이름의 InnoDB 테이블을 생성하여 InnoDB의 잠금 정보를 Dump 하거나 `SHOW_ENGINE_STATUS` 명령이 전부였다.
- 최근 버전에서는 information_schema 데이터에비스에 존재하는 `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS` 라는 테이블을 조인해서 조회하면 잠금 정보 확인이 가능하다.
    - 또한 장시간 잠금을 가지고 있는 클라이언트를 찾아서 종료시킬 수도 있다.

## 5.3.1 InnoDB 스토리지 엔진의 잠금

> InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기에 레코드 락이 페이지 락/테이블으로 에스컬레이션 되는 경우는 잘 없다.
>

### 5.3.1.1  레코드 락

- 레코드 자체만을 잠그는 것을 레코드 락 이라고 하며, 다른 사용 DBMS와 이 개념은 동일하다.
- 한 가지 중요한 차이는 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 것
- 인덱스가 하나도 없는 테이블이라도, 내부적으로 자동 생성된 클러스터 인덱스를 사용하여 설정한다.|

### 5.3.1.2 갭 락

> 레코드 자체가 아닌, 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것
>
- 보통은 넥스트 키 락의 일부로 자주 사용된다.

### 5.3.1.3 넥스트 키 락

> 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
>

### 5.3.1.4 자동 증가 락

- MySQL에서는 자동 증가하는 숫자 값을 추출하기 위해 `AUTO_INCREMENT` 라는 칼럼 속성을 제공한다.
- `AUTO_INCREMENT` 칼럼이 사용된 테이블에 동시에 다른 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련 번호 값을 가진다.
- 해당 기능을 위해 InnoDB 스토리지 엔진 내부적으로 `AUTO_INCREMENT` 락이라고 칭하는 테이블 수준의 잠금을 사용한다.
    - 특성 상 당연하게도, `INSERT`나 `REPLACE` 같은 새로운 레코드 생성 시에만 필요하다.
    - `AUTO_INCREMENT` 락은 트랜잭션과 관계없이, `INSERT`나 `REPLACE` 문장에서 `AUTO_INCREMENT` 값을 가져오는 그 순간만 락이 걸린다.
    - 명시적으로 획득하고 해제하는 방법은 없으며, 아주 짧은 시간 잠금/해제되어 대부분 문제가 없다.
- 자동 증가 값이 한 번 증가하면 절대 줄어들지 않는 이유 : `AUTO_INCREMENT` 잠금을 최소화 하기 위해
    - 설령 INSERT 쿼리가 실패했더라도, 한 번 증가된 `AUTO_INCREMENT` 값은 그대로 남는다.

## 5.3.2 인덱스와 잠금

> InnoDB의 잠금과 인덱스는 상당히 중요한 연관관계가 있다.
>
- InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.
    - 즉, 변경해야할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.

### 예시로 이해해보자.

> **왜 MySQL InnoDB에서 인덱스 설계가 중요한가?**
>

```sql
-- employees 테이블
-- first_name 칼럼이 멤버로 담긴 ix_firstname 이라는 인덱스 존재
-- employees에서 firstname이 'Georgi'인 사원은 253명
-- employees에서 전체 사원은 약 30만 명
UPDATE employees SET hire_date=NOW() WHERE first_name='Georgi' AND last_name='Klassen'
```

- 위 1건의 업데이트 쿼리를 위해 몇 개의 레코드에 락을 걸어야 할까?
- 현재 쿼리에서 first_name에 걸린 인덱스가 존재하기에, 253개의 레코드가 모두 잠긴다.
- 만약 first_name에 해당하는 인덱스가 없었다면 어떻게 될까?
    - 적절한 인덱스가 준비되어 있지 않다면, 테이블을 풀 스캔하면서 UPDATE 작업을 진행한다.
    - 즉, UPDATE 과정에서 30여만건의 모든 레코드를 잠그게 된다.
    - 이것이 MySQL 방식이며, InnoDB에서 인덱스 설계가 중요한 이유이다.

## 5.3.3 레코드 수준의 잠금 확인 및 해제

> 테이블의 레코드 수준 잠금은 테이블 수준의 잠금보다는 조금 더 복잡하다.
>
- 테이블 잠금에서는 잠금의 대상이 테이블 자체이므로, 쉽게 문제의 원인이 발견되고 해결될 수 있으나, 레코드 수준의 잠금은 테이블의 레코드 각각에 잠금이 걸리므로, 그 레코드가 자주사용되지 않는다면 오랜 시간 잠겨진 상태로 남아 있어도 잘 발견되지 않는다.
- 예전 버전의 MySQL 서버는 레코드 잠금에 대한 메타 정보(딕셔너리 테이블)를 제공하지 않아 더욱 문제

### 버전 별 레코드 잠금과 잠금 대기에 대한 조회

**MySQL 5.1 이후**

- `information_schema` DB의 `INNODB_TRX` 테이블과 `INNODB_LOCKS`, `INNODB_WAITS` 테이블을 통해 확인

**MySQL 8.0 이후**

- `information_schema` 의 정보들이 점점 Deprecated 되고 있다.
- `performance_schema`의 `data_locks`와 `data_lock_waits` 테이블로 대체되고 있다.

# 5.4 MySQL의 격리 수준

> 트랜잭션의 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.
>

### 격리 수준 리스트

> 격리 수준이 높아질수록 성능 차이가 클 것이라 생각할 수 있는데, `SERIALIZABLE` 가 아닌 이상 크게 성능의 개선이나 차이는 발생하지 않는다.
>
1. READ UNCOMMITTED
    - DIRTY READ 라고도 한다.
    - 일반적인 데이터베이스에서 잘 사용하지 않는다.
2. READ COMMITTED
    - 오라클과 같은 DBMS 주로 사용
3. REPEATABLE READ
    - MySQL에서 주로 사용
4. SERIALIZABLE
    1. 동시성이 중요한 데이터베이스에서는 거의 사용되지 않는다.

### 격리 수준 별 부정합 발생 여부

|  | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ |
| --- | --- | --- | --- |
| READ UNCOMMITTED | 발생 | 발생 | 발생 |
| READ COMMITTED | 없음 | 발생 | 발생 |
| REPEATABLE READ | 없음 | 없음 | 발생 (InnoDB는 없음) |
| SERIALIZABLE | 없음 | 없음 | 없음 |

## 5.4.1 READ UNCOMMITTED

> 각 트랜잭션의 변경 내용이 `COMMIT`이나 `ROLLBACK` 여부에 관계없이 다른 트랜잭션에서 보인다.
>
- 이렇게 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상을 `DIRTY READ` 라 하고, 그것이 허용되는 격리 수준이 `READ UNCOMMITTED` 이다.

## 5.4.2 READ COMMITTED

> 오라클 DBMS에서 기본으로 사용되는 격리 수준으로, 온라인 서비스에서 가장 많이 선택된다.
>
- 이 레벨에서는 위에서 언급한 `DIRTY READ` 현상은 발생하지 않는다.
- 하지만 이 레벨에서도 `NON-REPEATABLE READ` 현상은 존재한다.
    - `REPEATABLE READ` 가 불가능하다는 것
    - 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다.
        - 이걸 `REPEATABLE READ` 정합성 이라고 한다.
- `NON-REPEATABLE READ` 현상은 일반적인 웹 프로그램에서는 크게 문제되지 않을 수 있지만, 하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면문제가 될 수도 있다.
    - 다른 트랜잭션에서 입금과 출금 처리가 계속 진행될 때 한 트랜잭션에서 오늘 입금된 금액이나 잔액을 본다면? 계속 바뀌어 혼란을 야기할 것이다.
    - 이러한  `REPEATABLE READ` 를 보장해주는 격리 수준이 아래의 `REPEATABLE READ` 이다.

## 5.4.3 REPEATABLE READ

> MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다.
>
- 바이너리 로그를 가진 MySQL 서버에서는 최소 `REPEATABLE READ` 이상의 격리 수준을 사용해야 한다.
- `REPEATABLE READ` 는 언두(Undo) 영역에 백업된 이전 데이터를 이용하여, 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다.
- `READ COMMITTED`와 `REPEATABLE READ`의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있다.

### 고유한 트랜잭션 번호

> 모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호(순차적으로 증가하는 값)를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함되어 있다.
>
- 언두 영역의 백업된 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제
- `REPEATABLE READ` 격리 수준에서는 MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수 없다.
- 그렇다고 가장 오래된 트랜잭션 번호 이전의 트랜잭션에 의해 변경된 모든 언두 데이터가 필요한 것은 아니다.
    - 더 정확하게는 특정 트랜잭션 번호의 구간 내에서 백업된 언두 데이터가 보존돼야 한다.
- 기록된 언두 로그를 순차적으로 확인하여 트랜잭션 번호를 확인하기에, 언두에 백업된 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있다.
    - `BEGIN` 으로 트랜잭션을 시작하고 장시간 종료하지 않으면 언두 영역이 백업된 데이터로 무한정 커질 수도 있다.

### PHANTOM READ

> `PHANTOM ROW` 라고도 불린다.
>
- `SELECT … FOR UPDATE` 쿼리는 SELECT 하는 레코드에 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없다.
    - 그래서 이 경우, 언두 로그의 변경 전 데이터를 가져오는 것이 아닌, 현재 레코드의 값을 가져온다.

## 5.4.4 SERIALIZABLE

> 가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준이다.
>
- InnoDB 테이블에서 기본적으로 순수한 SELECT 작업은 아무런 레코드 잠금을 설정하지 않고 실행된다.
- InnoDB 메뉴얼의 **Non-lockig consistent read (잠금이 필요없는 일관된 읽기)** 가 이것이다.
- 하지만 트랜잭션의 격리 수준이 `SERIALIZABLE` 로 설정되면 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 번겅하지 못하게 된다.
- `SERIALIZABLE` 수준에서는 상단의 `PHANTOM READ` 문제가 발생하지 않는다.
    - 하지만 InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 `REPEATABLE READ` 수준에서도 이미 `PHANTOM READ` 가 발생하지 않기에, 굳이 `SERIALIZABLE` 은 사용하지 않는 것이 좋아보인다.