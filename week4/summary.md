### 4주차 질문 정리

1. InnoDB 스토리지 엔진은 REPEATABLE READ 격리수준이지만 넥스트 키 락을 사용하여 팬텀 리드(PHANTOM READ)를 없앴다고 하였는데, 그러면 Serializable 격리수준과 같은 게 아닌가?
    - 결론은 아니다
        - `SERIALIZABLE`: 일반 SELECT 연산에서도 락을 검
        - `REPEATABLE READ`: 일반 SELECT 연산에서는 락을 걸지 않음 (MVCC로 스냅샷 조회)
    - InnoDB 스토리지 엔진은 범위 검색에서만 넥스트 키 락을 걸어서 Phantom Read를 막을 뿐, 그 이외의 동시성 제어에서는 `SERIALIZABLE`보다 느슨하다.
        - 특정 범위에서 생성되는 레코드들에 대해서만 잠금이 영향을 주고, 범위에 해당하지 않는 값에 대해서는 여전히 자유롭게 조회가 가능하다는 것이 차별점이다.
2. 웹 서비스에서 트랜잭션의 범위를 최대한 좁게 설정하는 것이 좋다고 하는데, 그걸 애플리케이션용 코드(ex. spring)로 어떻게 적용하는 지 잘 모르겠습니다.
    - Spring의 `@Transactional` 어노테이션은, 해당 메서드의 동일 트랜잭션 상 수행을 보장한다.
    - 이 메소드에서 넓은 범위를 감싸기 보다, 네트워크 처리, 외부 API 호출 등의 작업을 제외한 필수적으로 묶여야할 최소한의 DB 작업 단위로만 트랜잭션을 유지하자
    - 다만 이 `@Transactional` 은 public 메소드에만 유효하며, 같은 클래스 내부의 다른 `@Transactional` 로 선언된 메소드를 직접 호출하는 것은 트랜잭션이 적용되지 않는다.
        - `@Transactional` 자체가 프록시로 원본 메소드를 감싸 구현하기에, 위 2가지 제약사항이 발생한다.
3. 레코드 자체를 잠그느냐, 인덱스를 잠그느냐의 차이가 뭔가요?
    - InnoDB는 레코드 자체가 아닌 인덱스를 기준으로 잠금을 건다.
    - 따라서 인덱스가 없거나 인덱스를 사용하지 않는 쿼리는 테이블 풀 스캔이 발생하며, 모든 레코드에 락이 걸릴 수 있다.(`SELECT ... FOR UPDATE` 의 경우)
        - 각 레코드에 락을 걸고 조건 확인하는 방식으로 스캔이 이뤄지는데, 인덱스가 없으면 이게 모든 레코드에 대해 진행된다.
        - 인덱스가 있다면 유효한 범위만 잠금하기에 인덱스가 있어야 한다는 것
    - 실제 락의 종류는 레코드 락(특정 인덱스 레코드), 갭 락(레코드 사이 간격), 넥스트 키 락(레코드+갭)으로 나뉜다.
        - `Supremum pseudo-record` 라는 가상의 끝 레코드를 통해, 마지막 실제 레코드와 supremum(상한) 사이의 범위(마지막 레코드, +∞)에 갭 락을 걸 수 있다고 한다.
        - 레코드 사이의 간격이라고 표현했지만, 사실상 존재하지 않는 레코드 까지 범위 개념으로 잠금할 수 있는 것
4. 갭 락과 넥스트 락에 대해 명확하게 이해를 하지 못하였고, 왜 이 2개의 락이 데드락을 자주 발생시키는 지 모르겠습니다.
    - 레코드 락은 개별 레코드, 갭 락은 레코드 사이의 간격, 넥스트 키 락은 특정 레코드와 그 레코드 이전 갭을 함께 잠그는 방식이다.
    - 갭 락과 넥스트 키 락은 존재하지 않는 범위까지 잠그기 때문에, 여러 트랜잭션이 서로 다른 순서로 갭을 잠그려 할 때 데드락이 발생하기 쉽다.
        - 데드락은 특히 동일한 갭에 대해 여러 트랜잭션이 동시에 INSERT를 시도할 때 빈번하게 발생한다고 한다.
5. 온라인 서비스에서 주로 READ COMMITTED 격리 수준이 선택된다고 하는데 보통 어떤 격리 수준을 사용하나요? 그리고 프로젝트 과정 중 특정 문제로 인해 격리 수준을 변경한 경험이 있으신지 궁금합니다.
    - 아직 스터디원 중 격리 수준을 제어할 정도의 필요가 있었던 인원은 없으나, 조회 중심 서비스에서는 `READ COMMITTED`를, 데이터 무결성이 중요한 서비스에서는 `REPEATABLE READ`를 사용하는 것이 일반적이라는 의견이 나왔다.
    - 책에 나왔던 것 처럼 Oracle은 `READ COMMITTED`, MySQL은 `REPEATABLE READ` 가 기본 설정이다.