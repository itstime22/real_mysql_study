## 8.3.7 B-Tree 인덱스의 가용성과 효율성

### 8.3.7.1 비교 조건의 종류와 효율성

다중 컬럼 인덱스에서는 각 컬럼의 **순서**와 **비교 조건의 종류**(동등 비교인지, 범위 비교인지)에 따라 인덱스 활용 방식과 효율이 달라진다.

다음 쿼리를 예로 살펴본다.

```sql
SELECT *
FROM dept_emp
WHERE dept_no = 'd002'
  AND emp_no >= 10114;
```

위 쿼리를 위해 다음 두 가지 인덱스를 생성했다고 가정한다.

- 케이스 A: `INDEX(dept_no, emp_no)`
- 케이스 B: `INDEX(emp_no, dept_no)`

**케이스 A**

- `dept_no = 'd002'` 조건으로 작업 범위를 먼저 결정
- 그 범위 내에서 `emp_no >= 10114` 조건 적용
- 조건을 만족하지 않을 때까지 인덱스를 순차적으로 탐색
- 읽은 레코드는 모두 결과로 사용 가능

→ **작업 범위 결정 조건을 효율적으로 사용**

**케이스 B**

- `emp_no >= 10114` 조건으로 먼저 인덱스 탐색
- 이후 모든 레코드에 대해 `dept_no = 'd002'` 조건을 개별 비교
- 불필요한 레코드까지 다수 읽게 됨

→ **`dept_no` 조건은 필터링 조건으로만 사용**

이처럼 **작업 범위를 줄이는 조건**과 **단순히 결과를 걸러내는 조건(필터링 조건)**은 구분된다.

- 작업 범위 결정 조건이 많을수록 성능이 좋아진다.
- 필터링 조건이 많아져도 성능 향상에는 큰 도움이 되지 않는다.

### 8.3.7.2 인덱스의 가용성

B-Tree 인덱스는 **왼쪽 값부터 정렬(Left-most)** 되어 있다는 특징이 있다.

이 규칙은 단일 컬럼 인덱스뿐 아니라 **다중 컬럼 인덱스**에도 동일하게 적용된다.

- 케이스 A: `INDEX(first_name)`
- 케이스 B: `INDEX(dept_no, emp_no)`

**Left-most 규칙**

- 인덱스는 **왼쪽 컬럼 값이 고정**되어야 인덱스 탐색 가능
- 왼쪽 컬럼 조건이 없으면 인덱스 레인지 스캔 불가
- 예시:
    
    ```sql
    SELECT *
    FROM employees
    WHERE first_name LIKE '%mer';
    ```
    
    - `%`로 시작하는 LIKE 패턴은 왼쪽 값이 고정되지 않음
    - B-Tree 인덱스를 레인지 스캔 방식으로 사용할 수 없음
    
    ```sql
    SELECT *
    FROM dept_emp
    WHERE emp_no = 10144;
    ```
    
    - 인덱스가 `(dept_no, emp_no)` 순서라면
    - `dept_no` 조건 없이 `emp_no`만으로는 인덱스를 효율적으로 사용할 수 없음

이 규칙은 WHERE 절뿐 아니라 **GROUP BY, ORDER BY** 절에도 동일하게 적용된다.

### 8.3.7.3 가용성과 효율성 판단

B-Tree 인덱스의 특성상 다음 조건에서는 **작업 범위 결정 조건으로 사용할 수 없다.** (단, 경우에 따라 체크 조건으로는 사용 가능)

- **사용 불가능한 경우**
    - **NOT EQUAL 비교**
        - `<>`, `NOT IN`, `NOT BETWEEN`, `IS NOT NULL`
    - **LIKE 패턴이 왼쪽부터 일치하지 않는 경우**
        - `LIKE '%승환'`
        - `LIKE '_승환'`
    - **인덱스 컬럼을 변형하는 연산**
        - `SUBSTRING(column, 1, 1) = 'X'`
        - `DAYOFMONTH(column) = 1`
    - **비결정적 함수 사용**
        - `column = non_deterministic_function()`
    - **데이터 타입이 달라 변환이 필요한 경우**
        - `char_column = 10`
    - **문자열 컬럼의 Collation이 다른 경우**
- MySQL은 NULL 값도 인덱스에 저장하므로 다음 조건은 **작업 범위 결정 조건으로 사용 가능**하다.
    
    ```sql
    WHERE column IS NULL
    ```
    

- **다중 컬럼 인덱스 사용 판단**
    
    다음 인덱스가 있다고 가정
    
    ```sql
    INDEX ix_test (column_1, column_2, column_3, ..., column_n)
    ```
    
    - **작업 범위 결정 조건으로 사용할 수 없는 경우**
        - `column_1`에 대한 조건이 없는 경우
        - `column_1`의 조건이 인덱스 사용 불가 조건인 경우
    - 작업 범위 결정 조건으로 사용할 수 있는 경우
        - `column_1 = 상수`
        - `column_1 IN (...)`
        - `column_1 >`, `<`, `>=`, `<=`
        - `column_1 LIKE 'prefix%'`
    
    이 조건이 만족되면, 그 이후 컬럼들도 순차적으로 조건에 따라 활용된다.
    

# 8.4 R-Tree 인덱스

R-Tree 인덱스는 **공간 데이터(Spatial Data)** 를 저장하고 검색하기 위한 인덱스이다.

B-Tree가 1차원 값 기준 인덱스라면, R-Tree는 **2차원 공간 개념**을 인덱싱한다.

MySQL에서는 공간 인덱스를 통해 위치 기반 검색을 지원한다.

## 8.4.1 구조 및 특성

MySQL은 공간 정보를 저장하기 위해 다음과 같은 Geometry 타입을 제공한다.

- POINT
- LINE
- POLYGON
- GEOMETRY (상위 타입)

공간 인덱스는 **MBR(Minimum Bounding Rectangle)** 개념을 사용한다.

- MBR: 도형을 감싸는 최소 사각형
- 이 MBR의 포함 관계를 B-Tree 구조로 관리한 것이 R-Tree 인덱스
- R-Tree 구조
    - 상위 노드: 하위 도형 그룹의 MBR
    - 하위 노드: 실제 도형의 MBR
    - 리프 노드: 실제 공간 데이터

## 8.4.2 R-Tree 인덱스의 용도

- R-Tree는 **포함 관계 기반 검색**에 사용된다.
- 대표적인 사용 함수:
    - `ST_Contains()`
    - `ST_Within()`
- 예시 흐름:
    1. 사각 박스(MBR)로 1차 필터링
    2. 필요 시 거리 계산 함수로 추가 필터링
    
    ```sql
    SELECT *
    FROM tb_location
    WHERE ST_Contains(사각상자, px)
      AND ST_Distance_Sphere(p, px) <= 5000;
    
    ```
    
    - 공간 인덱스는 **사각형 포함 여부까지만** 효율적으로 처리
    - 정확한 거리 계산은 후처리로 수행

# 8.5 전문 검색 인덱스

지금까지 살펴본 인덱스는 일반적으로 **작은 크기의 데이터** 또는 **이미 키워드화된 값**을 대상으로 한 인덱스였다.

MySQL의 B-Tree 인덱스는 실제 컬럼 값 전체를 인덱스 키로 사용하는 것이 아니라, 컬럼 값의 **일부(prefix)** 만 인덱스로 사용한다.

하지만 **문서 전체 내용**을 대상으로 특정 키워드를 포함한 문서를 검색하는 경우에는 일반적인 B-Tree 인덱스를 사용할 수 없다.

이러한 검색을 위해 사용되는 것이 **전문(Full Text) 검색 인덱스**이다.

전문 검색 인덱스는 일반화된 기능의 명칭이며, 특정 알고리즘의 이름을 의미하지는 않는다.

MySQL 8.0부터는 InnoDB가 기본 스토리지 엔진이 되었으므로, 이 절에서는 **InnoDB 기반 전문 검색 인덱스**를 중심으로 설명한다.

## 8.5.1 인덱스 알고리즘

전문 검색에서는 문서 본문의 내용을 분석하여 **검색 가능한 키워드 단위로 인덱스를 생성**한다.

키워드를 분석하고 인덱스를 구성하는 방식에 따라 다음 두 가지로 구분된다.

- 어근 분석 알고리즘
- n-gram 알고리즘

(MySQL 8.0부터는 구분자 방식이 n-gram 알고리즘에 포함되므로 별도로 다루지 않는다.)

### 8.5.1.1 어근 분석 알고리즘

전문 검색 인덱스는 다음 두 단계를 거쳐 생성된다.

- **불용어(Stop Word) 처리**
    - 불용어는 검색에서 의미가 없는 단어를 의미하며, 인덱스 생성 시 제거된다.
    - 불용어 개수는 많지 않기 때문에 보통 코드에 상수로 정의되어 사용되며, 경우에 따라 데이터베이스에 저장해 관리하기도 한다.
    - MySQL은 기본 불용어 목록을 제공하며, 사용자가 이를 무시하거나 별도로 정의할 수 있다.
- **어근 분석(Stemming)**
    - 어근 분석은 검색어의 **원형(root)** 을 추출하는 작업이다.
    - MySQL은 오픈소스 형태소 분석기 **MeCab**을 플러그인 형태로 지원한다.
        - 영어: 어근 분석이 효과적
        - 한국어, 일본어: 단어 변형이 거의 없어 형태소 분석이 더 중요
    - MeCab은 일본어 기반으로 개발되었으나, 한국어와 일본어의 문법 구조가 유사해 한국어 분석에도 활용할 수 있다.
    - 다만, 실제 적용을 위해서는 단어 사전과 문장 구조 인식이 필요하므로 설정과 준비 작업이 복잡하다.

### 8.5.1.2 n-gram 알고리즘

- 형태소 분석은 정확하지만 구현과 관리 비용이 크다.
- 이를 보완하기 위해 **n-gram 알고리즘**이 사용된다.
- n-gram은 문장을 **n개의 문자 단위로 잘라 토큰화**하는 방식이다.
    - n: 최소 토큰 길이
    - MySQL에서는 보통 **2-gram(bi-gram)** 이 사용됨
- 예시 문장: `To be or not to be. That is the question`
    - 공백과 문장부호 기준으로 단어 분리
    - 각 단어를 2글자씩 중첩 분리
    - 생성된 토큰을 인덱스에 저장
    - 중복 토큰은 하나의 인덱스 엔트리로 관리
- n-gram은 언어에 대한 이해가 필요 없고 적용이 쉽지만, **인덱스 크기가 커진다**는 단점이 있다.

### 8.5.1.3 불용어 변경 및 삭제

기본 불용어 처리 결과를 보면, 실제 검색에 방해가 되는 경우도 많다.

따라서 다음과 같은 방식이 권장된다.

- **전문 검색 인덱스의 불용어 처리 무시**
    - **방법 1: 서버 전체 불용어 제거**
        
        ```java
        ft_stopword_file=''
        ```
        
        - MySQL 서버 재시작 필요
        - 모든 전문 검색 인덱스에 적용
    - **방법 2: InnoDB 전문 검색 인덱스만 불용어 제거**
        
        ```sql
        SET GLOBAL innodb_ft_enable_stopword=OFF;
        ```
        
        - 동적 시스템 변수
        - InnoDB 테이블에만 적용
- **사용자 정의 불용어 사용**
    - **방법 1: 파일 기반**
        
        ```
        ft_stopword_file='/data/my_custom_stopword.txt'
        ```
        
    - **방법 2: 테이블 기반 (InnoDB 전용)**
        
        ```sql
        SET GLOBAL innodb_ft_server_stopword_table='mydb/my_stopword';
        ```
        
        - 불용어 테이블 변경 후 **전문 검색 인덱스 재생성 필요**

## 8.5.2 전문 검색 인덱스의 가용성

전문 검색 인덱스를 사용하려면 다음 두 조건을 반드시 만족해야 한다.

- `MATCH(...) AGAINST(...)` 구문 사용
- 전문 검색 인덱스가 생성된 컬럼을 MATCH 절에 명시

```sql
SELECT *
FROM tb_test
WHERE MATCH(doc_body) AGAINST('애플' IN BOOLEAN MODE);
```

LIKE 검색은 전문 검색 인덱스를 사용하지 못하고 **테이블 풀 스캔**이 수행된다.

# 8.6 함수 기반 인덱스

일반적인 인덱스는 컬럼 값 자체에만 생성할 수 있다.

하지만 **컬럼 값을 변형한 결과**에 대해 검색해야 하는 경우 함수 기반 인덱스를 사용할 수 있다.

MySQL 8.0부터 함수 기반 인덱스를 지원한다.

### 8.6.1 가상 컬럼을 이용한 인덱스

MySQL 8.0 이전에는 함수 결과를 인덱싱하기 위해 컬럼을 직접 추가해야 했다.

MySQL 8.0부터는 **가상 컬럼(VIRTUAL / STORED)** 을 이용할 수 있다.

```sql
ALTER TABLE user
ADD full_name VARCHAR(30)
  AS (CONCAT(first_name,' ',last_name)) VIRTUAL,
ADD INDEX ix_fullname (full_name);
```

- 가상 컬럼도 인덱스 생성 가능
- 실제 테이블 구조 변경 효과 있음

### 8.6.2 함수를 이용한 인덱스

MySQL 8.0부터는 테이블 구조를 변경하지 않고도 함수 기반 인덱스를 생성할 수 있다.

```sql
INDEX ix_fullname ((CONCAT(first_name,' ',last_name)))
```

- WHERE 조건의 표현식이 **인덱스 정의와 완전히 동일**해야 사용 가능
- 표현식이 다르면 옵티마이저는 인덱스를 사용하지 않음
- 내부적으로는 가상 컬럼 방식과 동일하게 처리된다.

# 8.7 멀티 밸류 인덱스

일반 인덱스는 **레코드 1건당 인덱스 키 1개**를 가진다.

멀티 밸류 인덱스는 **하나의 레코드에 여러 개의 인덱스 키**를 허용한다.

MySQL 8.0부터 JSON 배열 컬럼을 대상으로 멀티 밸류 인덱스를 지원한다.

- **특징**
    - JSON 배열 내부의 각 요소(Element)를 인덱싱
    - 정규화 관점에서는 비정상 구조
    - JSON 지원 강화로 실무 활용 가능

# 8.8 클러스터링 인덱스 (Clustering Index)

- **개념**
    - **클러스터링 인덱스 = 테이블 자체가 프라이머리 키 순서로 정렬되어 저장**
    - MySQL에서는 **InnoDB 스토리지 엔진에서만 지원**
    - 프라이머리 키 값이 **레코드의 물리적 저장 위치를 결정**

> 즉,
> 
> 
> **InnoDB 테이블 = 클러스터링 테이블**
> 
> **프라이머리 키 = 클러스터링 키**
> 

## 8.8.1 클러스터링 인덱스의 특징

### **핵심 특징**

- 프라이머리 키 값이 비슷한 레코드들이 **같은 데이터 페이지에 묶여 저장**
- 프라이머리 키 변경 시 → **레코드의 물리적 위치 변경 발생**
- **테이블당 클러스터링 인덱스는 1개만 가능**

### **프라이머리 키가 없을 때 InnoDB 선택 순서**

1. 명시적 **PRIMARY KEY**
2. **NOT NULL + UNIQUE 인덱스** 중 첫 번째
3. 내부적으로 **숨겨진 ROW ID(자동 생성)**

> 프라이머리 키를 명시하지 않으면 의미 없는 값으로 클러스터링됨
> 
> 
> → 성능상 이점 거의 없음 → **반드시 PK 정의 권장**
> 

## 8.8.2 클러스터링 인덱스가 세컨더리 인덱스에 미치는 영향

### **MyISAM vs InnoDB 차이**

- **MyISAM**
    - 세컨더리 인덱스 → **레코드의 물리 주소(ROWID)** 저장
    - 인덱스 → 바로 데이터 접근
- **InnoDB**
    - 세컨더리 인덱스 → **프라이머리 키 값 저장**
    - 실행 흐름:
        1. 세컨더리 인덱스 검색
        2. 프라이머리 키 획득
        3. 클러스터링 인덱스 재검색
        
        **→ InnoDB는 인덱스 탐색이 한 단계 더 필요**
        

## 8.8.3 클러스터링 인덱스의 장단점

### **장점**

- 프라이머리 키 기반 검색 성능 매우 빠름
- 프라이머리 키 **범위 검색**에 특히 유리
- 세컨더리 인덱스가 프라이머리 키를 포함 → **커버링 인덱스 가능성 증가**

### **단점**

- 모든 세컨더리 인덱스가 **프라이머리 키를 포함** → 인덱스 크기 증가
- INSERT 시 레코드 위치 계산 필요 → 쓰기 성능 저하
- 프라이머리 키 변경 → DELETE + INSERT와 유사한 비용 발생

## 8.8.4 클러스터링 테이블 사용 시 주의사항

### **8.8.4.1 클러스터링 인덱스 키 크기**

- 프라이머리 키 크기 ↑ → 모든 세컨더리 인덱스 크기 ↑
- 레코드 수가 많을수록 **메모리·디스크 사용량 급증**
- **PK는 최대한 작게**

### **8.8.4.2 AUTO_INCREMENT vs 업무 컬럼**

- **AUTO_INCREMENT가 좋은 경우**
    - 프라이머리 키가 너무 길어지는 경우
    - INSERT 성능이 중요한 경우 (순차 삽입)
- **업무 컬럼이 좋은 경우**
    - 자주 검색되는 핵심 컬럼
    - 범위 조회가 잦은 컬럼

### **8.8.4.3 프라이머리 키는 반드시 명시**

- PK 없으면 InnoDB가 내부 ROW ID 생성
- 사용자는 접근 불가
- 클러스터링 효과 없음
- **AUTO_INCREMENT라도 PK는 명시**

### **8.8.4.4 AUTO_INCREMENT를 인조 식별자로 사용하는 경우**

- 복합 PK → 너무 큼
- 세컨더리 인덱스도 함께 커짐
- AUTO_INCREMENT 단일 PK
- 업무 컬럼은 **UNIQUE 인덱스**로 관리

# 8.9 유니크 인덱스 (Unique Index)

- 개념
    - **중복을 허용하지 않는 인덱스**
    - 사실상 “제약 조건 + 인덱스” 성격
- 특징
    - NULL 값은 여러 개 허용 (NULL ≠ NULL)
    - InnoDB에서:
        - PRIMARY KEY → 클러스터링 키
        - UNIQUE INDEX → 일반 세컨더리 인덱스

## 8.9.1 유니크 인덱스 vs 일반 세컨더리 인덱스

- **읽기 성능**
    - 거의 차이 없음
    - 디스크 I/O 관점에서는 동일
- **쓰기 성능**
    - 유니크 인덱스는 **중복 검사 추가**
    - INSERT / UPDATE 시 **더 느림**
- **읽기 빠르다고 무조건 유니크 쓰면 안 됨**

## 8.9.2 유니크 인덱스 사용 시 주의사항

- 중복 방지가 **목적일 때만 사용**
- 같은 컬럼에
    - UNIQUE INDEX
    - 일반 INDEX
    - **동시에 생성 X (중복 인덱스)**
- 유니크 인덱스는 중복 없는 세컨더리 인덱스 역할도 이미 수행

# 8.10 외래키 (Foreign Key)

- **기본 특징**
    - **InnoDB에서만 지원**
    - 외래키 생성 시:
        - 참조 컬럼에 **자동 인덱스 생성**
    - 외래키 삭제 전에는 해당 인덱스 삭제 불가
- **InnoDB 외래키의 핵심 특성**
    1. **변경 대상 테이블에 대해서만 잠금 경합 발생**
    2. 외래키와 **무관한 컬럼 변경은 잠금 영향 없음**

## 8.10.1 자식 테이블 변경이 대기하는 경우

- 부모 테이블 레코드가 **쓰기 잠금 상태**
- 자식 테이블에서 해당 부모 키를 참조하는 변경 시도 → 부모 잠금 해제까지 **대기**
- 자식 테이블 변경은 **부모 테이블 상태에 의존**

## 8.10.2 부모 테이블 변경이 대기하는 경우

- 자식 테이블이 부모 레코드를 참조 중
- 부모 테이블에서 DELETE / UPDATE
- 자식 테이블 검사 필요
- 자식 테이블의 잠금 해제까지 대기
- `ON DELETE CASCADE`가 있으면 **자식도 함께 처리**