# 8.4 R-Tree 인덱스

> 공간 인덱스, 2차원의 공간 개념 값
GIS나 GPS 등에 대해, MySQL의 공간 확장(Spatial Extension)을 이용하면 간단하게 구현 가능하다.
>

### MySQL 공간 확장의 3가지 기능

1. 공간 데이터를 저장할 수 있는 데이터 타입
2. 공간 데이터의 검색을 위한 공간 인덱스(R-Tree) 알고리즘
3. 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리)

## 8.4.1 구조 및 특성

### 데이터 타입

- **POINT**: 점
- **LINE**: 선
- **POLYGON**: 도형
- **GEOMETRY**: 위 3가지 타입의 슈퍼 타입

### MBR(Minimum Bounding Rectangle)

- 해당 도형을 감싸는 최소 크기의 사각형
- 최상위 레벨 / 차상위 레벨 / 최하위 레벨로 감싸는 범위에 따라 구분된다.
- 상위 레벨일 수록 R-Tree의 루트 노드와 가까우며, 최상위 MBR은 루트 노드에 해당한다.

## 8.4.2 R-Tree 인덱스의 용도

R-Tree는 위 MBR 정보를 이용해 B-Tree 형태로 인덱스를 구축한다.

- Rectangle의 `R` + B-Tree의 `Tree` = `R-Tree`

기본적으로 WGS84(GPS) 기준의 위도/경도 좌표 저장에 주로 사용된다.

CAD/CAM 소프트웨어 또는 회로 디자인 등과 같이
좌표 시스템에 기반을 둔 정보에 대해서는 모두 적용할 수 있다.

R-Tree는 각 도형(MBR)의 포함 관계를 이용해 만들어진 인덱스 이기에, 활용 방식도 아래와 같다.

- 대표적으로는 `현재 사용자의 위치로 부터 반경 5km 이내의 음식점 검색` 등
- 위 경우 MBR 기준으로는 원이 아닌 사각형 형태이기에, 사각형에는 포함되지만 원에는 벗어나는 등의 데이터는 온전한 인덱스 활용에선 걸러낼 수 없다.
- 해당 값을 포함해도 무방하다면 `ST_Contains()` 또는 `ST_Within()` 를 사용하자.
- 반드시 제거해야한다면 `ST_Distance_Sphere()` 함수를 통해 거리 필터링을 진행하자.
- `ST_Contains()` 또는 `ST_Within()` 등과 같은 포함 관계 비교 함수로 검색 수행하는 경우에만 인덱스를 이용할 수 있다.

# 8.5 전문 검색 인덱스

B-Tree 인덱스의 특성상 전체 일치 또는 좌측 일부 일치와 같은 검색만 가능했다.

문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문(Full Test) 검색에는 MyISAM이나 InnoDB에서 제공하는 일반적인 용도의 B-Tree 인덱스를 사용할 수 없다.

## 8.5.1 인덱스 알고리즘

전문 검색에서는 문서 본문의 내용에서 사용자가 검색하게 될 키워드를 분석해내고,
빠른 검색용으로 사용할 수 있게 이러한 키워드로 인덱스를 구축한다.

문서의 키워드를 인덱싱하는 방법에 따라 크게 단어의 **어근 분석**과 **n-gram 분석 알고리즘**으로 나뉜다.

## 8.5.1.1 어근 분석 알고리즘

MySQL 서버의 전문 검색 인덱스는 다음 2가지 중요 과정을 거쳐 색인 작업이 수행된다.

1. 불용어(Stop Word) 처리
    - 검색에서 별 가치가 없는 단어를 모두 필터링해서 제거하는 작업
2. 어근 분석(Stemming)
    - 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업
    - MySQL에서는 오픈소스 형태소 분석 라이브러리인 MeCab을 플러그인 형태로 지원한다.
        - 기본적으로는 일본어 대상 프로그램이지만, 한국어와 유사하여 MeCab을 사용한다.
        - MeCab 프로그램만 가져다 설치한다고 다가 아니라, 단어 사전이 필요하며, 문장을 해체해서 각 단어의 품사를 식별할 수 있는 문장의 구조 인식이 필요하다.

## 8.5.1.2 **n-gram 분석 알고리즘**

형태소 분석이 문장을 이해하는 알고리즘이라면, n-gram은 단순히 키워드 검색을 위한 인덱싱 알고리즘이다.

n-gram이란 본문을 무조건 몇 글자씩 잘라서 인덱싱하는 방법이다.
형태소 분석보다 알고리즘이 단순하고 국가별 언어에 대한 이해 및 준비 작업이 필요없다.

N-gram에서 N개의 단어씩 묶어 토큰으로 관리되며, 각 단어는 중첩되어 토큰으로 구분된다.

이렇게 구분된 각 토큰은 인덱스에 저장되며, 중복된 토큰은 하나의 인덱스 엔트리로 병합되어 저장된다.

MySQL에서는 이렇게 생성된 토큰들에 대해 불용어를 걸러내는 작업을 수행한다.

`information_schema.innodb_ft_default_stopword` 테이블에 불용어 목록이 등록되어있으며,

a, what, at, the, with, i, of 등의 단어들이 존재한다.

토큰들에서 불용어와 일치하거나 불용어를 포함하는 토큰은 제외하고, 최종 인덱스에 등록된다.

다만 a, i 같은 불용어 등록 시 버려지는 범위가 넓어져 사용자의 혼란을 야기하기에,
MySQL 지원 불용어 직접 사용대신 불용어를 커스텀하여 등록하여 사용하는 것이 권장된다.

- 불용어 목록을 파일로 저장하고, MySQL 서버 설정 파일에서 파일 경로를 설정하는 방법
    - ft_stopword_file = `‘{file_path}’`
- 불용어의 목록을 테이블로 저장하는 방식
    - InnoDB 스토리지 엔진을 사용하는 테이블의 점문 검색 엔진에서만 사용 가능하다.
    - 불용어 테이블을 생성하고, `innodb_ft_server_stopword_table`에 설정한다.

## 8.5.2. 전문 검색 인덱스의 가용성

전문 검색 인덱스의 사용을 위해서는 반드시 다음 2가지 조건을 갖춰야 한다,

- 쿼리 문장이 전문 검색을 위한 문법(MATCH … AGAINST …)을 사용
- 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유
- e.g.
    - 적용 X: `SELECT * FROM tb_test WHERE doc_body LIKE ‘%애플%’;`
    - 적용 O: `SELECT * FROM tb_test WHERE MATCH(doc_body) AGAINST(’애플’ IN BOOLEAN MODE);`

# 8.6 함수 기반 인덱스

일반적인 인덱스는 칼럼의 값 일부(칼럼의 값 앞부분) 또는 전체에 대해서만 인덱스 생성이 허용된다.

하지만 때로는 칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축해야할 때도 있는데,
이때 함수 기반의 인덱스를 활용하면 된다.

함수 기반 인덱스의 구현 방법은 다음 2가지와 같다.

- 가상 칼럼을 이용한 인덱스
- 함수를 이용한 인덱스

MySQL 서버의 함수 기반 인덱스는 인덱싱할 값을 계산하는 과정의 차이만 있을 뿐, 실제 인덱스의 내부적인 구조 및 유지관리 방법은 B-Tree 인덱스와 동일하다.

## 8.6.1 가상 칼럼을 이용한 인덱스

기존 버전에는 실제 칼럼을 추가하고 모든 레코드에 대해 업데이트를 진행해야겠지만, 아래 처럼 가능하다.

```sql
ALTER TABLE user (
	ADD full_name VARCHAR(30) AS (CONCAT(first_name,' ',last_name)) VIRTUAL,
	ADD INDEX ix_fullname (full_name);
```

## 8.6.2 함수를 이용한 인덱스

MySQL 8.0 버전부터 테이블 구조 변경 없이 함수를 직접 생성하는 인덱스 생성이 가능해졌다.

다만 이 인덱스를 제대로 활용하려면 함수 생성 시 명시된 표현식과 WHERE 문 조건절이 일치해야한다.

```sql
CREATE TABLE user (
	user_id BIGINT,
	first_name VARCHAR(10),
	last_name VARCHAR(10),
	PRIMARY_KEY (user_id),
	INDEX ix_full_name ((CONCAT(first_name,' ',last_name)))
);
```

# 8.7 멀티 밸류 인덱스

전문 검색 인덱스를 제외한 모든 인덱스는 레코드 1건이 1개의 인덱스 키 값을 가진다.
즉 인덱스 키와 데이터 레코드가 1:1로 대응 관계를 가지는 것

멀티 벨류 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스

일반적으론 정규화에 위배되는 형태이지만, 최근 RDBMS 들이 JSON 데이터 타입을 지원하여 발생했다.

멀티 벨류 인덱스의 활용을 위해서는 반드시 다음 함수들을 이용해서 검색해야 옵티마이저가 인덱스를 활용한 실행 계획을 수립한다.

- `MEMBER_OF()`
- `JSON_CONTAINS()`
- `JSON_OVERLAPS()`

# 8.8 클러스터링 인덱스

클러스터링은 여러 개를 하나로 묶는다는 의미로 주로 사용되는데, MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것(PK 기준)들끼리 묶어서 저장하는 형태로 구현된다.

이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것이다.

PK값이 비슷한 레코드끼리 묶어서 저장하는 것이 결국 클러스터링 인덱스인데,
여기서 중요한 것은 PK 값에 의해 레코드의 저장 위치가 결정된다는 것이다.

또한 PK 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것을 의미하기도 한다.

클러스터링 인덱스는 PK에 의해 레코드의 저장위치가 결정되므로, 사실 인덱스 알고리즘이라기보다 테이블 레코드의 저장 방식이라고 볼 수 있다.
그래서 `클러스터링 인덱스`와 `클러스터링 테이블`은 동의어로 사용되기도 한다.

> `UPDATE tb_test SET emp_no=100002 WHERE emp_no=100007`
>

처럼 PK를 직접적으로 변경 시, 클러스터링 테이블에서 저장위치가 직접적으로 변경되는 것을 확인 가능하다.

## 세컨더리 인덱스에 미치는 영향

MyISAM이나 MEMORY 처럼 클러스터링되지 않은 테이블은 처음 저장된 공간에서 절대 이동하지 않는다.

데이터 레코드가 저장된 주소는 내부적인 레코드 아이디(ROWID) 역할을 하며, PK나 세컨더리 인덱스의 각 키는 그 주소(ROWID)를 이용하여 실제 데이터 레코드를 찾아온다.

그래서 MyISAM이나 MEMORY 에서는 PK와 세컨더리 인덱스가 구조적으로 아무런 차이가 없다.

InnoDB에서는 클러스터링 키 값이 변경될 때 마다 데이터 레코드의 주소가 변경되고, 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야할 것이기에, 오버헤드 제거를 위해 InnoDB 테이블의 모든 세컨더리 인덱스는 해당 레코드의 저장된 주소가 아니라 PK를 저장하도록 구현돼 있다.

## 클러스터링 인덱스의 장점과 단점

### 장점

- PK로 검색할 때 처리 성능이 매우 빠름(특히 PK를 범위 검색하는 경우)
- 테이블의 모든 세컨더리 인덱스가 PK를 가지기에 인덱스만으로 처리될 수 있는 경우가 많음

### 단점

- 테이블의 모든 세컨더리 인덱스가 PK를 가지기에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐

    > 레코드 건수에 따라 인덱스 크기가 기하급수 적으로 증가할 수 있어 InnoDB PK는 신중히 선택하자
    >
- 세컨더리 인덱스를 통해 검색 시 PK로 다시 한 번 검색해야하므로 처리 성능이 느림
- INSERT 시 PK에 의해 레코드의 저장 위치가 변경되기에 처리 성능이 느림
- PK 변경 시 레코드를 DELETE 하고 INSERT하는 작업이 필요하여 처리 성능이 느림

# 8.9 유니크 인덱스

유니크는 사실 인덱스라기 보다는 제약조건에 가깝다고 볼 수 있다.

유니크 인덱스와 유니크하지 않은 일반 세컨더리 인덱스는 사실 인덱스 구조상 아무런 차이점이 없다.

유니크하지 않은 일반 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것이지,
인덱스 자체의 특성 때문에 느린것은 아니다.

유니크 인덱스 키 값 쓰기 시, 중복된 값을 체크하는 과정이 한 단계 더 필요하기에,
유니크하지 않은 일반 세컨더리 인덱스보다 쓰기 작업이 느리다.

꼭 유일성이 보장되어야 하는 칼럼에 대해서는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 유니크 인덱스보다는 유니크하지 않은 세컨더리 인덱스를 생성하는 방법도 한 번씩 고려해보자.

# 8.10 외래키

MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있으며, 외래키 제약 설정 시 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다.

외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 생성할 수 없다.

InnoDB 외래키 관리에는 중요한 2가지 특징이 있다.

- 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.

자식 테이블의 생성 시, 부모 테이블에 해당 참조 키가 존재하는지 확인한다는 것은 알고 있을텐데,
이처럼 DB에서 외래키를 물리적으로 생성 시 이런 잠금 경합까지 고려해 모델링을 진행해야 한다.