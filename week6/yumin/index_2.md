# 3. B-Tree 인덱스

## 📌 **B-Tree 인덱스의 가용성과 효율성**

### ✅ **비교 조건의 종류와 효율성**

다중 칼럼 인덱스에서 **칼럼의 순서**와 **조건의 형태**(`=` 인지 범위 조건인지)가 효율성에 큰 영향

- **효율적인 케이스 (작업 범위 결정 조건):**
    - ex) `INDEX (dept_no, emp_no)` 순서로 생성된 경우, `dept_no='d002' AND emp_no >= 10114` 쿼리는 매우 효율적
    - `dept_no`가 동등 비교(`=`)로 범위를 좁히고, `emp_no`가 그 범위 내에서 시작점을 찾으므로 불필요한 비교가 거의 없음
- **비효율적인 케이스 (필터링 조건):**
    - ex) `INDEX (emp_no, dept_no)` 순서라면, `emp_no >= 10114` 조건으로 먼저 범위를 찾고, 그 범위 내의 모든 레코드에 대해 `dept_no='d002'`인지 일일이 확인 필요
    - 이 경우 `dept_no`는 검색 범위를 좁히는 데 도움을 주지 못하고, 단순히 조건에 맞는지 검사하는 용도로만 사용됩니다.
- **작업 범위 결정 조건 vs 필터링 조건**
    - **작업 범위 결정 조건 (Access Condition):** 검색해야 할 레코드의 범위를 실제로 줄여주는 조건
    → 이 조건이 많을수록 쿼리 성능이 좋아짐
    - **필터링 조건 (Check Condition):** 범위를 줄이지 못하고, 읽어온 데이터가 조건에 맞는지 단순히 확인(거름종이 역할)만 하는 조건 
    → 이 조건은 쿼리 성능을 높이지 못하고, 오히려 느리게 만들 수 있음

### ✅ **인덱스의 가용성**

B-Tree 인덱스는 왼쪽 값(Left-most)을 기준으로 정렬
→ 이 특성 때문에 인덱스를 사용할 수 없는 경우들이 발생

- **왼쪽 부분이 고정되지 않은 경우:**
    - `LIKE '%mer'`와 같이 앞부분이 와일드카드인 경우, 정렬 순서를 활용할 수 없어 인덱스 레인지 스캔이 불가능
- **다중 칼럼 인덱스에서 선행 칼럼 조건이 없는 경우:**
    - 인덱스가 `(dept_no, emp_no)` 순서인데 `dept_no` 조건 없이 `emp_no`로만 검색하면 인덱스를 효율적으로 사용할 수 없음
    - 이는 `emp_no`가 `dept_no`에 의존해서 정렬되어 있기 때문

### ✅ **가용성과 효율성 판단**

다음과 같은 경우에는 B-Tree 인덱스를 **작업 범위 결정 조건**으로 사용할 수 없음

1. **NOT-EQUAL 비교:** `<>`, `NOT IN`, `NOT BETWEEN`, `IS NOT NULL`
2. **뒷부분 일치 문자열 패턴:** `LIKE '%단어'` (앞부분이 변하므로 정렬 활용 불가)
3. **인덱스 칼럼이 변형된 경우:** 스토어드 함수나 연산자로 칼럼을 가공한 후 비교할 때 
4. **데이터 타입 불일치:** 인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우 (예: 문자열 칼럼을 숫자로 비교).
5. **콜레이션 불일치:** 문자열 데이터 타입의 콜레이션이 다른 경우

# 4. R-Tree 인덱스

**R-Tree 인덱스는 2차원의 공간 데이터(위도, 경도 등)를 저장하고 검색하는 데 특화**된 인덱스
기본적인 내부 메커니즘은 B-Tree와 비슷하지만, B-Tree가 1차원 값을 다루는 반면 R-Tree는 **2차원의 공간 개념 값**을 다룸

## 📌 구조 및 특성

MySQL은 공간 데이터를 저장하기 위해 다음과 같은 데이터 타입을 제공

- POINT: 점
- LINE: 선
- POLYGON: 다각형
- GEOMETRY: 나머지 3개를 모두 포함하는 상위 타입
    
    
- **핵심 개념: MBR (Minimum Bounding Rectangle)**
    - **정의:** 해당 도형(점, 선, 면)을 감싸는 **최소 크기의 사각형**을 의미
    - **원리:** 이 사각형(MBR)들의 **포함 관계**를 이용해 B-Tree 형태로 인덱스를 구축한 것
    - 인덱스는 다음과 같이 계층적으로 구성
        - **최하위 레벨 (리프 노드):** 실제 각 도형 데이터의 MBR이 저장
        - **차상위 레벨 (브랜치 노드):** 하위 레벨의 MBR들을 그룹화하여 감싸는 더 큰 MBR이 저장
        - **최상위 레벨 (루트 노드):** 가장 큰 MBR 그룹이 저장

## 📌 R-Tree 인덱스의 용도

주로 위도, 경도 좌표를 저장하는 **GPS(WGS84) 기반 서비스**나 CAD/CAM 소프트웨어 등 좌표 시스템에 기반을 둔 정보 시스템에 사용

# 5. 전문 검색 인덱스

문서 내용 전체를 검색하거나 중간에 포함된 단어를 찾을 때는 사용하는 인덱스

## 📌 인덱스 알고리즘

- 불용어(Stop Word) 처리 → 검색에서 별 가치가 없는 단어를 모두 필터링해서 제거하는 작업
- 어근 분석(Stemming) → 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업

### ✅ 어근 분석 알고리즘

- 단어의 뿌리를 찾아서 인덱싱하는 방식
- 단점: 문맥을 이해해야 하므로 구축 시간이 오래 걸리고 단어 사전이 필요=

### ✅ n-gram 알고리즘

- MeCab의 복잡함을 해결하기 위해 도입된 단순한 방식
- **작동 방식:** 본문을 무조건 **n글자씩(주로 2글자) 잘라서 토큰**으로 만들고 인덱싱
- **불용어(Stopword) 처리**

### ✅ 불용어 변경 및 삭제

n-gram 방식은 문장을 무조건 자르기 때문에 `a`, `is`, `ti` 처럼 검색에 도움 되지 않는 글자들까지 인덱싱될 수 있음 → 이를 걸러내는 것이 **불용어 처리**

- **해결 방법 (사용자 정의):**
    1. **불용어 무시:** ft_stopword_file=''로 설정하거나, innodb_ft_enable_stopword를 OFF로 설정해 내장 불용어를 끄기
    2. **사용자 정의 불용어:** 별도의 불용어 파일을 만들거나 테이블에 불용어를 저장해 적용

## 📌 전문 검색 인덱스의 가용성

전문 검색 인덱스를 사용하기 위한 두 가지 조건

1. 쿼리 문장이 전문 검색을 위한 문법(MATCH … AGAINST …)을 사용
2. 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유

# 6. 함수 기반 인덱스

- MySQL 서버는 함수 기반 인덱스를 구현하기 위해 두 가지 방법을 제공
- 내부적인 구현 방식과 성능은 동일
- 조건절(WHERE)에 사용된 표현식이 인덱스 정의와 완벽하게 일치해야함

## 📌 가상 컬럼을 이용한 인덱스

- **방법:** 테이블에 새로운 가상 칼럼을 추가하고, 그 칼럼에 인덱스를 생성하는 방식
- **특징:** 테이블 구조가 실제로 변경된다는(가상 칼럼 추가) 단점

## 📌 함수를 이용한 인덱스

- **방법:** 테이블 구조를 건드리지 않고, 인덱스 생성 구문에 직접 함수 표현식 넣기
- **특징:** 계산된 결과값 검색을 빠르게 만들어 줌

# 7. 멀티 밸류 인덱스

- 레코드 1건이 여러 개의 인덱스 키를 가질 수 있는 형태
- JSON 배열 안에 있는 값들 하나하나에 인덱스를 걸 수 있음. 단, `MEMBER OF()` 같은 전용 함수를 써야 함

# 8. 클러스터링 인덱스

- 클러스터링 인덱스는 프라이머리 키(PK) 값이 비슷한 레코드끼리 묶어서 저장하는 인덱스
- MySQL에서는 **InnoDB 스토리지 엔진**에서만 지원하는 기능

## 📌 클러스터링 인덱스

- **PK = 물리적 주소:** 프라이머리 키 값에 의해 레코드의 물리적인 저장 위치가 결정
→ PK 값이 바뀌면 레코드가 저장된 물리적인 위치도 이동 필요
- **리프 노드 = 데이터:** 일반적인 B-Tree 인덱스의 리프 노드에는 인덱스 키와 주소가 있지만, 클러스터링 인덱스의 리프 노드에는 **레코드의 모든 칼럼 데이터**가 저장

## 📌 세컨더리 인덱스에 미치는 영향

- **MyISAM:** 세컨더리 인덱스는 레코드의 물리적 주소(ROWID)를 저장
- **InnoDB:** 세컨더리 인덱스는 레코드의 주소가 아니라 **프라이머리 키(PK) 값**을 저장
    - **이유:** PK가 변경되어 레코드의 물리적 위치가 바뀌더라도, 세컨더리 인덱스를 갱신할 필요가 없게 하기 위함(오버헤드 감소)
    - **검색 과정:** 세컨더리 인덱스 검색 ➔ PK 획득 ➔ PK로 클러스터링 인덱스 검색 ➔ 최종 데이터 획득 (총 2단계)

## 📌 클러스터링 인덱스의 장점과 단점

- **장점:**
    - PK를 이용한 검색(특히 범위 검색)이 매우 빠름
    - 모든 세컨더리 인덱스가 PK를 포함하므로 **커버링 인덱스** 처리가 될 가능성이 높음
- **단점:**
    - PK가 클 경우 **모든 세컨더리 인덱스의 크기가 급격히 커짐**
    - INSERT 시 PK 순서대로 정렬해야 하므로 쓰기 성능이 느림
    - 세컨더리 인덱스를 통한 검색은 PK를 한 번 더 찾아야 하므로 일반적인 경우보다 조금 느릴 수 있음

## 📌 클러스터링 테이블 사용 시 주의사항

- PK 크기를 최소화
- 가능하면 업무적으로 의미 있는 칼럼을 PK로 사용

# 9. 유니크 인덱스

인덱스보단 중복을 허용하지 않는 제약 조건에 가까움

## 📌 유니크 인덱스와 일반 세컨더리 인덱스 비교

- 유니크 인덱스는 1건만 찾으면 멈추고, 일반 인덱스는 중복된 값이 더 있는지 확인하기 위해 조금 더 읽을 뿐
- 디스크 I/O가 아니라 **메모리 상의 CPU 작업 차이이므로 성능 영향은 미미**
- 새로운 레코드를 넣을 때 중복 체크를 해야 하므로, 일반 인덱스보다 **쓰기 작업이 더 느림**
- 특히 유니크 인덱스는 중복 체크 때문에 **체인지 버퍼(Change Buffer)** 기능을 사용할 수 없음 (버퍼링 불가)

## 📌 유니크 인덱스 사용 시 주의사항

- 새로운 레코드를 넣을 때 중복 체크를 해야 하므로, 일반 인덱스보다 **쓰기 작업이 더 느림**
- 특히 유니크 인덱스는 중복 체크 때문에 **체인지 버퍼(Change Buffer)** 기능을 사용할 수 없음 (버퍼링 불가)

# 10. 외래키 인덱스

- InnoDB 외래키 관리에는 중요한 2가지 특징
    - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.
    - 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.

## 📌 자식 테이블의 변경이 대기하는 경우

부모 테이블의 데이터가 변경 중일 때, 자식 테이블에서 외래키 칼럼을 변경하려고 하면 대기가 발생

## 📌 부모 테이블의 변경 작업이 대기하는 경우

자식 테이블의 데이터가 변경 중일 때, 부모 테이블에서 해당 레코드를 삭제하려고 하면 대기가 발생
