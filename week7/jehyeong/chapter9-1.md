- MySQL에 요청된 쿼리의 결과는 동일하지만 내부적으로 그 결과를 만들어내는 방법은 매우 다양하다.
- MySQL 서버를 포함한 대부분의 DBMS에선 옵티마이저가 데이터를 비교, 최적의 실행 계획을 수립한다.
- MySQL에서는 EXPLAIN이라는 명령으로 쿼리의 실행 계획을 확인할 수 있는데,
  이 실행 계획에 표시되는 내용을 제대로 이해하려면 옵티마이저가 실행하는 최적화를 이해해야한다.

# 9.1 개요

> 실행 계획을 이해할 수 있어야만 실행 계획의 불합리한 부분을 찾아내고,
더 최적화된 방법으로 실행 계획을 수립하도록 유도할 수 있다.
>

## 9.1.1 쿼리 실행 절차

**MySQL 서버에서 쿼리 실행 과정은 크게 세 단계로 나눌 수 있다.**

1. 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블 부터, 어떤 인덱스를 이용하여 읽을지 선택한다.
3. 2단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용, 스토리지 엔진에서 데이터를 가져온다.

### 첫 번째 단계: SQL 파싱(Parsing)

MySQL 서버의 “SQL 파서”라는 모듈로 처리한다.

- SQL 문장이 문법적으로 잘못됐다면 이 단계에서 걸러진다.
- 이 단계에서 “SQL 파스 트리”가 만들어진다.
- MySQL 서버는 SQL 문장 그 자체가 아니라 SQL 파스 트리를 이용해 쿼리를 실행한다.

### 두 번째 단계: 최적화 및 실행 계획 수립

- 불필요한 조건 제거 및 복잡한 연산의 단순화
- 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
- 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

### 세 번째 단계: 실행

- 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청
- MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬 작업을 수행
- MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리

## 9.1.2 옵티마이저의 종류

> 옵티마이저는 DB 서버에서 두뇌와 같은 역할을 담당한다.
>

### 최적화 방식 2가지

1. **규칙 기반 최적화(Rule-based optimizer)**
    - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식
    - 통계 정보(테이블의 레코드 건수나 칼럼값의 분포도)를 조사하지 않고 실행 계획을 수립하기에, 같은 쿼리에 대해서는 거의 항상 같은 실행 방법이 생성된다.
    - 예전 초기 버전의 오라클 DBMS에서 많이 사용되었다.
2. **비용 기반 최적화(Cost-based optimizer)**
    - 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출
    - 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행

# 9.2 기본 데이터 처리

> MySQL에선 데이터를 정렬하거나 그룹핑하는 등의 기본 데이터 가공에 어떤 알고리즘을 사용할까?
>

## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

MySQL 옵티마이저는 다음 조건이 일치할 때 풀 테이블 스킨을 실시한다.

- 테이블의 레코드 건수가 너무 작아 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우 (인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)

**리드 어헤드**

- 어떤 영역의 데이터가 앞으로 필요할 것이라는 것을 예측하여 요청이 오기 전 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다두는 것을 의미한다. (InnoDB)
- 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드(Foreground) 스레드가 페이지 읽기를 실행하지만, 특정 시점 부터는 백그라운드 스레드로 넘어가 한번에 4개 또는 8개씩 페이지를 읽으면서 계속 그 수를 증가시킨다. 최대 64개의 데이터 페이지까지 읽어 버퍼 풀에저장해둔다.
- 포그라운드 스레드는 미리 버퍼풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 속도가 빨라진다.
- `innodb_read_ahead_threshold` 시스템 변수로 리드 어헤드 시작 임계값을 변경할 수 있다.
- 일반적으론 디폴트, 데이터 웨어하우스 용도라면 낮은 값으로 설정하는게 좋다.
- **리드 어헤드는 풀 테이블 스캔 뿐만 아니라 풀 인덱스 스캔에서도 동일하게 사용된다.**

## 9.2.2 병렬 처리

> MySQL 8.0 부터 쿼리의 병렬 처리가 가능해졌다.
병렬 처리는 **하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리하는 것**을 의미한다.
여러 쿼리를 여러 스레드가 동시 처리하는 것은 MySQL 시작때부터 가능했으니 혼동하지 말자.
>
- 현재 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리 가능하다.
- 병렬 처리용 스레드 개수가 서버의 CPU 개수를 넘어서면 오히려 성능이 감소할 수 있음을 알자.

## 9.2.3 ORDER BY 처리(Using filesort)

> MySQL에서 정렬을 처리하는 방법을 알아보자
>

|  | 장점 | 단점 |
| --- | --- | --- |
| 인덱스 이용 | INSERT / UPDATE / DELETE 쿼리 실행 시 이미 인덱스가 정렬되어 순서대로 읽기만 하면 되므로 매우 빠르다. | INSERT / UPDATE / DELETE 쿼리 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하여 느리다. 
인덱스로 인해 디스크 공간이 더 많이 필요하며, InnoDB 버퍼 풀을 위한 메모리가 많이 필요하다. |
| Filesort 이용 | 인덱스를 생성하지 않아도 된다.
정렬해야할 레코드가 많지 않다면 메모리에서 Filesort가 처리되기에 충분히 빠르다. | 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리 응답 속도가 느리다. |

**아래와 같은 경우 Filesort 정렬 과정을 거친다.**

- 정렬 기준이 너무 많아 요건별로 모두 인덱스 생성이 불가능한 경우
- GROUP BY 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

> 실행 계획의 Extra 칼럼에 “Using filesort” 메세지가 표시되는지 여부로
정렬에서의 인덱스 이용 여부를 확인할 수 있다.
>

### 9.2.3.1 소트 버퍼

> MySQL에서의 정렬 수행을 위해 별도의 메모리 공간을 할당받아 사용하는데,
이 메모리 공간을 소트 버퍼(Sort Buffer) 라고 한다.
>

정렬해야할 레코드 건수가 소트 버퍼로 할당된 공간보다 크다면 어떨까?

- 메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 저장해둔다.
- 이후 임시로 저장된 정렬 데이터들을 병합하며 정렬을 수행한다.
- 이 병합 작업을 멀티 머지(Multi-merge)라고 표현한다.
- 무작정 소트 버퍼가 크다고 빨라지는게 아니다. `56KB ~ 1MB 미만` 이 경험상 적절하다.
- 너무 큰 사이즈 할당 시 큰 메모리 공간 할당 대문에 성능이 훨씬 떨어질 수도 있다.
    - 10MB 이상으로 설정 시 대량의 레코드 정렬 쿼리가 여러 커넥션에서 동시에 실행되며 운영체제가 메모리 부족 현상을 겪을 수도 있다.
    - 이후 OOM-Killer가 메모리를 가장 많이 사용하는 프로세스 강제 종료 시 대상이 될 수 있다.

### 9.2.3.2 정렬 알고리즘

> 레코드 정렬 시 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라
싱글 패스와 투 패스 2가지 정렬 모드로 나눌 수 있다.
정렬을 수행하는 쿼리가 어떤 정렬 모드를 사용하는지는 옵티마이저 트레이스 기능으로 확인할 수 있다.
>

```sql
SET OPTIMIZER_TRACE="enabled=on",END_MARKERS_IN_JSON=on;
SET OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;

-- 정렬 사용 쿼리 실행

SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE \G;
```

**싱글 패스 정렬 방식**

> 소트 버퍼에 정렬 기준 칼럼을 포함해 `SELECT` 대상 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식
정렬에 필요하지 않은 칼럼까지 전부 읽어 소트 버퍼에 담고 정렬을 수행한다.
>

```sql
-- 이 쿼리를 실행한다고 가정하고, 하단 이미지들을 살펴보자.
SELECT emp_no, first_name, last_name
FROM employees
ORDER BY first_name;
```

![](https://i.imgur.com/huLSkp6.png)

**투 패스 정렬 방식**

> 정렬 대상 칼럼과 PK 값만 소트 버퍼에 담아 정렬을 수행하고,
정렬된 순서대로 다시 PK로 테이블을 읽어 SELECT 할 칼럼을 가져오는 정렬 방식이다.
>
- 싱글 패스 정렬 방식 등장 전부터 이용되던 방식으로, 8.0에서도 특정 조건에서 투 패스를 사용한다.
    - 레코드의 크기가 `max_length_for_sort_data` 시스템 변수에 설정된 값 보다 클 때
    - BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함될 때
- 테이블을 2번 읽기에 상당히 불합리하지만, 싱글 패스는 더 많은 소트 버퍼 공간이 필요하다.
- 정렬 대상 레코드의 크기나 건수가 작은 경우 싱글 패스 방식이, 많은 경우 투 패스 방식이 효율적이다.

![](https://i.imgur.com/Xp6R2Yl.png)

### 9.2.3.3 정렬 처리 방법

> 쿼리에 `ORDER BY`가 사용되면 반드시 다음 3가지 처리 방법 중 하나로 정렬이 처리된다.
일반적으로 아래로 갈 수록처리 속도는 떨어진다.
>

인덱스 사용이 가능하다면 Filesort가 필요없지만, 사용할 수 없다면 하단 2가지 방법 중 하나를 사용한다.

일반적으로 조인이 수행되면 레코드 건수와 크기가 배수로 불어나기에,
가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 방법이 효율적이다.

|  | 실행 계획의 Extra 칼럼 내용 | 전송 방식 |
| --- | --- | --- |
| **인덱스를 사용한 정렬** | 별도 표기 없음 | 스트리밍 방식 |
| **조인에서 드라이빙 테이블만 정렬** | “Using filesort” 메세지가 표기됨 | 버퍼링 방식 |
| **조인에서 조인 결과를 임시 테이블로 저장 후 정렬** | “Using temporary; Using filesort” 메세지가 표기됨 | 버퍼링 방식 |

**인덱스를 이용한 정렬**

> 드라이빙 테이블(Driving Table)은 
**SQL 쿼리에서 조인(Join)을 수행할 때 가장 먼저 접근하여 전체 쿼리 실행 경로를 주도하는 기준 테이블**
>
- 반드시 `ORDER BY` 에 명시된 칼럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, `ORDER BY` 의 순서대로 생성된 인덱스가 있어야 한다.
- 또한 WHERE 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.
- 인덱스를 이용해 정렬이 처리되는 경우에는 실제 인덱스의 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 된다.
- 실제로 MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행하지는 않는다.
- `ORDER BY` 절을 추가해도 성능상 손실이 없을 뿐더러, 예외 상황을 예방하기에, 굳이 제거하지 말자.

**조인의 드라이빙 테이블만 정렬**

- 일반적으로 조인 수행 시 레코드 건수와 크기가 몇 배로 불어난다.
- 그래서 조인 실행 전 **첫 번째 테이블(드라이빙 테이블)의 레코드를 먼저 정렬한 다음 조인을 실행하는 것**이 정렬의 차선책이 될 것이다.
- **이 방법으로 정렬이 처리되려면 조인에서 첫 번째로 읽히는 테이블, 드라이빙 테이블의 칼럼만으로 `ORDER BY` 절을 작성해야한다.**

**임시 테이블을 이용한 정렬**

> 2개 이상의 테이블을 조인해서 그 결과를 정렬해야한다면 임시 테이블이 필요할 수 있다.
앞에서 언급한 조인의 드라이빙 테이블만 정렬은 2개 이상이 테이블이 조인되면서 정렬이 실행되지만, 임시 테이블을 사용하지 않는다.
>

**정렬 처리 방법의 성능 비교**

> 웹 서비스용 쿼리에서는 ORDER BY와 LIMIT이 거의 필수로 사용되는 경향이 있다.
>

LIMIT은 테이블이나 처리 결과의 일부만 가져오기에, 작업량을 줄이는 역할이 있지만,
ORDER BY 또는 GROUP BY 같은 작업은 정렬/그룹핑이 선행되어야 하기에 영향이 없다.

WHERE 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 발생하는데, 왜 쿼리에서 인덱스를 사용하지 못하는 정렬이나 그룹핑 작업이 왜 느리게 작동할 수 밖에 없는지 살펴보자.

**스트리밍 방식**: 처리될 데이터가 얼마인지에 관계없이 조건에 일치하는 결과가 검색될 때 마다 바로바로 클라이언트로 전송해주는 방식

> 스트리밍 처리는 어떤 클라이언트 도구나 API를 사용하느냐에 따라 방식에 차이가 존재한다.
JDBC 라이브러리로 단순 SELECT 쿼리 시 MySQL 서버는 레코드를 읽자마자 결과를 전달할 것이다.
하지만 JDBC는 받은 레코드를 일단 내부 버퍼에 담아둔 후, 모든 결과가 와야 애플리케이션에 반환한다.
물론 기본 작동 방식일 뿐이며, 대량의 데이터가 필요할 땐 전송을 스트리밍 방식으로 변경할 수 있다.
>

**버퍼링 방식**: ORDER BY 또는 GROUP BY 같은 쿼리는 쿼리 결과 스트리밍 되는 것을 불가능하게 한다. WHERE 조건에 일치하는 모든 레코드를 가져온 후, 정렬하거나 그룹핑하여 차례대로 보내야 하기 때문.
스트리밍 방식의 반대 개념으로 나타내지는 개념이다.

## 9.2.4 GROUP BY 처리

> GROUP BY에 사용된 조건은 인덱스를 사용하여 처리될 수 없으므로,
HAVING 절을 튜닝하려고 인덱스를 생성하거나 다른 방법을 고민할 필요는 없다.
>

### 9.2.4.1 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)

이미 정렬된 인덱스를 읽는 것이기에 Extra 칼럼에 별도로 GROUP BY 관련 코멘트(Using Index for group-by)나 임시 테이블 사용 또는 정렬 관련 코멘트(Using temporary, Using filesort)가 표시되지 않는다.

### 9.2.4.2 루스 인덱스 스캔을 이용하는 GROUP BY

실행 계획의 Extra 칼럼에 “Using Index for group-by” 코멘트가 표시된다.

### 9.2.4.2 임시 테이블을 사용하는 GROUP BY

실행 계획의 Extra 칼럼에 “Using temporary” 코멘트가 표시된다.

임시 테이블이 사용된 것은 테이블을 풀 스캔 하기 때문이 아니라, 인덱스를 전혀 사용할 수 없는 GROUP BY이기 때문이다.

## 9.2.5 DISTINCT 처리

> 특정 칼럼의 유니크한 값만 조회하기 위해 사용한다.
`MIN()`, `MAX()` 또는 `COUNT()` 같은 집합 함수와 함꼐 사용되는 경우,
함꼐 사용하지 않는 경우의 2가지로 구분해서 보자.
>

### 9.2.5.1 SELECT DISTINCT …

> GROUP BY와 동일한 방식으로 처리된다. 다음 두 쿼리는 내부적으로 같은 작업을 수행한다.
>

```sql
SELECT DISTINCT emp_no FROM salaries;
SELECT emp_no FROM salaries GROUP BY emp_no;
```

DISTINCT 사용 시 자주 실수하는 것이 있다. DISTINCT는 SELECT 하는 레코드(튜플)를 유니크하게 SELECT 하는 것이지, 특정 칼럼만 유니크하게 조회하는 것이 아니라는 것.

즉, 아래 쿼리에서 SELECT 하는 결과는 first_name 만 유니크한 것을 가져오는 것이 아니라,
(first_name, last_name) 조합 전체가 유니크한 레코드를 가져오는 것이다.

`SELECT DISTINCT first_name, last_name FROM employees;`

DISTINCT는 함수가 아니기에, `SELECT DISTINCT(first_name), last_name FROM employees;` 처럼 쿼리하여도 의미 없는 괄호로 판단하여 제거해버린다.

### 9.2.5.2 집합 함수와 함께 사용된 DISTINCT

집합 함수 내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들을 가져온다.

DISTINCT가 집합 함수 없이 사용된 경우와 내에서 사용된 경우 결과가 달라지기에 차이를 정확히 이해하자.

```sql
-- 1
SELECT DISTINCT first_name, last_name
FROM employees
WHERE emp_no BETWEEN 10001 AND 10200;

-- 2
SELECT COUNT(DISTINCT first_name), COUNT(DISTINCT last_name)
FROM employees
WHERE emp_no BETWEEN 10001 AND 10200;

-- 3
SELECT DISTINCT COUNT(first_name, last_name)
FROM employees
WHERE emp_no BETWEEN 10001 AND 10200;
```

## 9.2.6 내부 임시 테이블 활용

> MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그룹핑할 때는 내부적인 임시 테이블을 사용한다. 내부적(Internal) 테이블은 `SELECT TEMPORARY TABLE` 로 생성되는 테이블 과는 다르다.
>

### 9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블

8.0 이전까지는 메모리 영역은 MEMORY, 디스크 영역은 MyISAM 테이블을 사용했으나,
8.0 이후부터는 TempTable 이라는 스토리지 엔진을, 디스크 역역은 InnoDB 스토리지 엔진을 사용한다.

### 9.2.6.2 임시 테이블이 필요한 쿼리

- `ORDER BY`와 `GROUP BY`에 명시된 칼럼이 다른 쿼리
- `ORDER BY`와 `GROUP BY`에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- `DISTINCT`와 `ORDER BY`가 동시에 쿼리에 존재하는 경우 또는 `DISTINCT`가 인덱스로 처리되지 못할 때
- `UNION`이나 `UNION DISTINCT`가 사용된 쿼리(`select_type` 칼럼이 `UNION RESULT`인 경우)
- 쿼리의 실행 계획에서 `select_type` 칼럼이 `DERIVED`인 쿼리

### 9.2.6.3 임시 테이블이 디스크에 생성되는 경우

- `UNION`이나 `UNION ALL`에서 SELECT 되는 칼럼 중에서 길이가 512 바이트 이상인 크기의 칼럼이 있을 때
- `GROUP BY` 나 `DISTINCT` 칼럼에서 512 바이트 이상인 크기 칼럼이 있는 경우
- 메모리 임시 테이블의 크기가 `tmp_table_size` 또는 `max_heap_table_size` 시스템 변수보다 크거나 `temptalbe_max_ram` 시스템 변수 값보다 큰 경우