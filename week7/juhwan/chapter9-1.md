# 📘 Chapter 9. 옵티마이저와 힌트

## 9.1 옵티마이저 개요

**● 옵티마이저란?**

- SQL 실행 계획을 결정하는 MySQL 엔진 내 컴포넌트
- 같은 SQL이라도 실행 방법은 여러 가지
- 그 중 "비용(cost)"이 가장 낮다고 판단한 실행 계획을 선택

> **핵심:**  
> SQL은 “무엇을” 실행할지 명시,  
> 옵티마이저는 “어떻게” 실행할지 결정

---

### 9.1.1 쿼리 실행 절차

1. **SQL 파싱**
2. **SQL 리라이트(Rewrite)**
   - 불필요 조건 제거
   - 서브쿼리 변환 등
3. **옵티마이저 실행**
   - 실행 계획 후보 생성
   - 각 후보 비용 계산
4. **실행 계획 선택**
5. **스토리지 엔진에서 실제 실행**

---

### 9.1.2 옵티마이저의 종류

- MySQL 옵티마이저는 **비용 기반(CBO)**
  - 규칙 기반(RBO) ❌
  - 비용 기반(CBO) ⭕

**비용 계산 기준**

- 읽어야 할 레코드 수
- 읽어야 할 페이지 수
- 랜덤/순차 I/O
- 인덱스 선택도(Selectivity)

---

## 9.2 기본 데이터 처리 방식

### 9.2.1 풀 테이블 스캔 & 풀 인덱스 스캔

- **풀 테이블 스캔 (Full Table Scan)**

  - 모든 레코드 전체를 순차적으로 읽음
  - 조건 만족 Row가 많을 때 오히려 유리
  - 순차 I/O → 대량 읽기에 효율적

- **인덱스 풀 스캔 (Index Full Scan)**
  - 인덱스를 처음부터 끝까지 스캔
  - 테이블보다 인덱스가 훨씬 작을 때 유리
  - 커버링 인덱스일수록 효과적

> 옵티마이저는 인덱스가 있다고 항상 사용하는 게 아니고  
> “비용이 더 싼 쪽”을 선택한다.

---

### 9.2.2 병렬 처리

- MySQL 8.0부터 일부 쿼리에 병렬 처리 적용
- 주 적용 대상:
  - 풀 테이블 스캔
  - 대용량 집계 작업
  - 모든 쿼리에 해당되지는 않음

---

### 9.2.3 ORDER BY 처리

- **Filesort**
  - 인덱스를 사용하지 못할 때 발생
  - 디스크/메모리에서 수동 정렬
- **인덱스 정렬**
  - ORDER BY 컬럼 순서 = 인덱스 순서
  - 추가 정렬 불필요하므로 가장 효율적

> 실행 계획에서  
> `"Using filesort"`  
> 가 보이면 성능 개선 여지를 반드시 검토

---

### 9.2.4 GROUP BY 처리

- 그룹화 처리 방식
  1. 인덱스 활용(가장 빠름)
  2. 임시 테이블 사용
  3. Filesort

> `GROUP BY`와 `ORDER BY`가 함께 있으면  
> 인덱스 설계가 특히 중요

---

### 9.2.5 DISTINCT 처리

- 내부적으로 GROUP BY와 유사하게 처리
- 인덱스 활용 시 중복제거 비용 최소화

---

## 9.3 조인 최적화

### 9.3.1 조인의 기본 원칙

- MySQL은 기본적으로 **Nested Loop Join** 사용
- 작은 테이블 → 큰 테이블 순으로 접근하는 게 빠름
- 드라이빙 테이블 선택이 **조인 성능의 핵심!**

---

### 9.3.2 조인 순서 최적화

- 옵티마이저는 테이블 순서를 자유롭게 바꿀 수 있음
- FROM절 순서 ≠ 실제 실행 순서
- 잘못된 순서를 강제로 주면 오히려 성능 저하 가능

---

### 9.3.3 세미 조인(Semi Join)

- 서브쿼리를 내부적으로 조인으로 변경
- EXISTS, IN 절 쿼리에 최적화 기법으로 사용
- MySQL 8.0에서 개선됨

---

## 9.4 옵티마이저 힌트

**힌트란?**

- 옵티마이저에게 “이렇게 실행해라”라고 강제하는 SQL 내 수단
- 절대 남용 금지! - "최후의 수단"으로만 사용

> **원칙:**  
> **옵티마이저가 "틀렸을 때만" 힌트 사용**

---

### 9.4.1 힌트의 종류

#### 🔹 인덱스 힌트

```sql
SELECT * FROM t USE INDEX (idx_name);
SELECT * FROM t FORCE INDEX (idx_name);
```

- USE INDEX → **참고**만 함
- FORCE INDEX → **강제** 사용

#### 🔹 옵티마이저 힌트(권장 방식)

```sql
SELECT /*+ INDEX(t idx_name) */ * FROM t;
```

- MySQL 8.0부터 표준화
- 인덱스 힌트보다 우선순위 더 높음

---

### 9.4.2 힌트 사용 시 주의사항

- 데이터 분포 변경 시 오히려 성능 저하 우려
- 인덱스/스키마 변경 시 힌트로 인해 장애 발생 가능
- 힌트는 코드에 남아 장기 유지보수 시 '빚'이 될 수 있음

> 힌트는 “응급 처치”이지 “정답”이 아니다!

---

## 9.5 옵티마이저가 틀리는 대표적 이유 & 해결책

**(1) 통계 정보 부정확**  
**(2) 데이터 분포 극단적**  
**(3) 히스토그램 부재**  
**(4) 조건절 복잡함**

**→ 문제 해결책:**

- `ANALYZE TABLE`로 최신 통계 정보 반영
- 히스토그램 생성/활용
- 인덱스 재설계
