**노션 링크: https://sweltering-diadem-a68.notion.site/2de55b9ff8dd808db169fb8fdfc26395?pvs=74**

# 옵티마이저와 힌트
- MySQL 서버로 요청된 쿼리는 결과는 동일하지만 **결과를 만들어내는 방법은 매우 다양함**
    
    → 가장 최적이고 최소의 비용이 소모되는 방법 도출 필요
    
- **최적의 실행 계획을 수립하는 작업을 옵티마이저**가 담당
    - MySQL에서는 EXPLAIN 명령으로 쿼리의 실행 계획 확인 (내용 출력)
    - 실행 계획 내용 이해를 위해 옵티마이저의 최적화에 대한 이해 필요

# 1. 개요

## 📌 쿼리 실행 절차

- MySQL 서버에서 쿼리가 실행되는 과정 3단계
    1. **SQL 파싱(Parsing) 단계**
        
        → 사용자로부터 요청된 **SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)**
        
        - MySQL 서버의 **SQL 파서**라는 모듈로 처리
        - SQL 문장이 문법적으로 잘못됐다면 이 단계에서 걸러짐
        - 이 단계에서 **SQL 파스 트리** 생성 → SQL 문장이 아닌 파스 트리로 쿼리 실행
    2. **최적화 및 실행 계획 수립 단계**
        
        → SQL의 **파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지** 선택
        
        - 만들어진 파스 트리를 참조하면서 다음 내용을 처리
            - 불필요한 조건 제거 및 복잡한 연산의 단순화
            - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
            - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
            - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
        - MySQL 서버의 **옵티마이저**에서 처리
        - 이 단계가 완료되면 쿼리의 **실행 계획** 생성
    3. **실행 단계**
        
        → 두 번째 단계에서 **결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져오기**
        
        - 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청
        - MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행
        - 1,2 단계와 달리 MySQL 엔진 뿐 아니라 **스토리지 엔진도 참여**
        

## 📌 **옵티마이저의 종류**

- **옵티마이저: 데이터베이스 서버에서 두뇌와 같은 역할 수행**
- 옵티마이저의 종류
    1. **규칙 기반 최적화 (Rule-based optimizer, RBO)**
        - 초기 버전의 오라클 DBMS에서 사용
        - 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 **옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립**
        - 통계 정보 조사 X → **같은 쿼리에 대해서는 거의 항상 같은 실행 방법**
    2. **비용 기반 최적화 (Cost-based optimizer, CBO)**
        - 현재 대부분의 DBMS가 사용
        - **쿼리를 처리하기 위한 여러 가지 가능한 방법**을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 **통계 정보를 이용해 실행 계획별 비용을 산출**
        - 산출된 실행 방법 별로 **비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행**
        

# 2. **기본 데이터 처리**

결과물이 동일하더라도 RDBMS 별로 결과를 만들어내는 과정이 다르기에 **MySQL 서버가 사용하는 알고리즘**에 대해 파악 필요

## 📌 **풀 테이블 스캔과 풀 인덱스 스캔**

- **풀 테이블 스캔: 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리**하는 작업
- **MySQL 옵티마이저가 풀 테이블 스캔을 선택하는 조건**
    - 테이블의 **레코드 건수가 너무 작아서** 인덱스를 통해 읽는 것보다 **풀 테이블 스캔을 하는 편이 더 빠른 경우** (일반적으로 테이블이 페이지 1개로 구성된 경우)
    - WHERE 절이나 ON 절에 **인덱스를 이용할 수 있는 적절한 조건이 없는 경우**
    - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 **조건 일치 레코드 건수가 너무 많은 경우**
- **리드 어헤드 (Read ahead):** 어떤 영역의 **데이터가 앞으로 필요해질 것을 예측**해서 **요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것**
- **InnoDB의 동작 방식**
    - InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작
    - 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드(클라이언트 스레드)가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘김
    - 백그라운드 스레드가 읽기를 넘겨받는 시점부터는 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가시킴. 이때 한 번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장
    - 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리
- **풀 인덱스 스캔 (Full Index Scan):** 풀 테이블 스캔이 테이블을 처음부터 끝까지 스캔하는 것을 의미하듯이, **인덱스를 처음부터 끝까지 스캔하는 것**
    - 리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 동일하게 사용
    
    ```sql
    SELECT COUNT(*) FROM employees;
    ```
    
    - 단순히 **레코드의 건수만 필요**로 하는 쿼리라면 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 횟수를 줄임
    - 일반적으로 인덱스는 테이블의 2~3개 칼럼만으로 구성되기 때문에 테이블 자체보다는 용량이 작아서 훨씬 빠른 처리가 가능
    
    ```jsx
    SELECT * FROM employees;
    ```
    
    - 하지만, **레코드에만 있는 칼럼이 필요**한 쿼리의 경우에는 풀 인덱스 스캔을 활용하지 못하고 풀 테이블 스캔
    

## 📌 **병렬 처리**

- MySQL 8.0 버전부터  **MySQL 서버에서도 쿼리의 병렬 처리**가 가능해짐
- **병렬 처리: 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리**
    
    (여러 스레드가 동시에 각각의 쿼리를 처리하는 것은 원래 가능)
    
- **innodb_parallel_read_threads**라는 시스템 변수로 **하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지를 변경** 가능
- MySQL 8.0 버전에서는 아무런 **WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리(`SELECT COUNT(*)`)만 병렬로 처리** 가능
- 병렬 처리용 스레드 개수를 아무리 늘리더라도 **서버에 장착된 CPU의 코어 개수를 넘어서는 경우**에는 **오히려 성능이 떨어질 수**도 있으니 주의

## 📌 **ORDER BY 처리**

- 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용
- 정렬 처리 방법
    1. **인덱스를 이용하는 방법**
    2. **Filesort라는 별도의 처리를 이용하는 방법**
- 모든 정렬을 인덱스를 이용할 수는 없기에 Filesort 방식도 사용함
- 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지 실행 계획의 Extra 칼럼에 `"Using filesort"` 메시지가 표시되는지 여부로 판단 가능

### ✔️ **소트 버퍼**

- **소트 버퍼 (Sort buffer): MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 의미**
- **특징:**
    - **소트 버퍼는 정렬이 필요한 경우에만 할당**되며, 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가하지만 최대 사용 가능한 소트 버퍼의 공간은 `sort_buffer_size`라는 시스템 변수로 설정 가능
    - 소트 버퍼를 위한 메모리 공간은 **쿼리의 실행이 완료되면 즉시 시스템으로 반납**
- **멀티 머지 (Multi-merge)**
    - 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면, MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 디스크를 사용합니다 .
    - 메모리의 **소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록해 둔 다음, 레코드를 다시 병합**하면서 정렬을 수행하는 것
    - **디스크의 쓰기와 읽기 유발**
- **소트 버퍼를 크게 설정하는 것이 실제 성능을 빠르도록 향상시키지 못함** (디스크 읽기/쓰기를 줄일 수는 있음)
    
    → **적절한 크기**(MySQL은 56KB~1MB)로 설정하는 것이 적절 
    

### ✔️ **정렬 알고리즘**

- 2가지 정렬 모드 (레코드를 정렬할 때 **레코드 전체를 소트 버퍼에 담을지** 또는 **정렬 기준 칼럼만 소트 버퍼에 담을지**에 따라**)**
    1. **싱글 패스(Single-pass)**
    2. **투 패스(Two-pass)**
- **싱글 패스 정렬 방식 (Single-pass)**
    - 소트 버퍼에 정렬 기준 칼럼을 포함해 **SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행**하는 정렬 방식
    - **정렬에 필요하지 않은 칼럼까지 전부 읽어서** 소트 버퍼에 담고 정렬을 수행한 뒤, 정렬이 완료되면 정렬 버퍼의 내용을 그대로 클라이언트로 넘겨주기
    - **테이블을 두 번 읽는 불합리가 없음**
    - 하지만, **더 많은 소트 버퍼 공간이 필요**
    - 최신 버전에서는 일반적으로 **싱글 패스 정렬 방식을 주로 사용**
- **투 패스 정렬 방식 (Two-pass)**
    - **정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행**하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬 방식
    - **테이블을 두 번 읽어야 하기에 불합리함**
    - 특정 상황에서는 투 패스 정렬 사용
        - 레코드의 크기가 `max_length_for_sort_data` 시스템 변수에 설정된 값보다 클 때
        - BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함될 때
- **비교:** **싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능**을 보이며, **투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적**

<aside>
💡

**[중요] SELECT 쿼리에서 모든 칼럼(`*`)을 가져오도록 개발**할 때가 많음
→ 이는 **정렬 버퍼를 몇 배에서 몇십 배까지 비효율적으로 사용**할 가능성이 큼
→ **정렬이 필요한 SELECT는 불필요한 칼럼을 SELECT하지 않게 쿼리를 작성**하는 것이 효율적

</aside>

### ✔️ **정렬 처리 방법 3가지**

**쿼리에 `ORDER BY`가 사용되면 반드시 다음 3가지 처리 방법 중 하나로 정렬이 처리**
(일반적으로 **아래쪽에 있는 정렬 방법으로 갈수록 처리 속도는 떨어짐**)

1. **인덱스를 이용한 정렬**
    - **실행 계획:** Extra 칼럼에 별도 표기가 없음
    - **`ORDER BY`에 명시된 칼럼이 제일 먼저 읽는 테이블**(조인이 사용된 경우 드라이빙 테이블)에 속하고, **`ORDER BY`의 순서대로 생성된 인덱스**가 있어야 함
    - `WHERE` 절에 **첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면** 그 조건과 **`ORDER BY`는 같은 인덱스를 사용**할 수 있어야 함
    - B-Tree 계열의 인덱스가 아닌 해시 인덱스나 전문 검색 인덱스 등에서는 사용할 수 없음
    - **실제 인덱스의 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만** 하면 됨
    (실제로 MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행 X)
2. **조인의 드라이빙 테이블만 정렬**
    - **실행 계획:** Extra 칼럼에 **`"Using filesort"`** 메시지가 표시
    - 일반적으로 **조인이 수행되면 결과 레코드의 건수가 몇 배로 불어나고, 레코드 하나하나의 크기도 늘어남** → 그래서 조인을 실행하기 전에 **첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행**하는 것이 정렬의 차선책
    - 조인에서 **첫 번째로 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 `ORDER BY` 절을 작성**해야 함
3. **임시 테이블을 이용한 정렬**
    - **실행 계획:** Extra 칼럼에 **`"Using temporary; Using filesort"`** 메시지가 표시
    - **2개 이상의 테이블을 조인해서 그 결과를 정렬**해야 한다면 임시 테이블이 필요할 수도 있음 → **조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬**하는 과정
    - 정렬해야 할 레코드 건수가 가장 많기 때문에 **가장 느린 정렬 방법**

### ✔️ **정렬 처리 방법의 성능**

<aside>
- 웹 서비스용 쿼리에서는 ORDER BY와 LIMIT이 거의 필수로 사용
- LIMIT → 테이블이나 처리 결과의 일부만 가져오기에, 서버의 작업량을 줄여줌
- ORDER BY 또는 GROUP BY → 조건을 만족하는 레코드를 모두 가져와서 정렬 수행 OR 그루핑 작업을 해야만 LIMIT으로 제한 가능
</aside>

- **웹 서비스(OLTP)에서는 쿼리의 요청에서부터 첫 번째 레코드를 전달 받게 되기까지의 응답 시간이 중요**
ex) 사용자가 버튼을 누르자마자 첫 번째 화면이 빠르게 뜨는 것이 중요
- **쿼리 처리 방식 2가지**
    1. **스트리밍 방식 (Streaming) - 인덱스 사용 정렬**
        - 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 **조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식**
        - **MySQL 서버가 레코드를 찾는 즉시 클라이언트로 보냄**
        → **웹서비스에 적합**
        - 이 방식에서 `LIMIT`처럼 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여줌
    2. **버퍼링 방식 (Buffering) - ORDER BY / GROUP BY 사용 시**
        - 조건에 맞는 **모든 레코드를 가져와서 정렬하거나 그루핑을 끝낸 뒤에야 전송을 시작하는 방식**
        - MySQL 서버에서는 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 하기 때문에 **응답 속도가 느림**
        - 이 방식은 `LIMIT`처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 별로 도움이 되지 않음

<aside>
💡

**[중요] 스트리밍 방식은 클라이언트 도구나 API에 의해 달라질 수 있음**

- JDBC는 MySQL이 보내주는 레코드를 **일단 자기 내부 버퍼에 모두 담아둠 (마지막까지 받아야 전달)**
- **대량의 데이터를 실시간으로 처리**해야 한다면 **JDBC의 전송 방식을 스트리밍으로 변경**하는 설정을 해야함 (MySQL이 아무리 빨리 줘도 JDBC가 다 받을 때까지 앱은 기다리게 되기에)
</aside>

## 📌 GROUP BY 처리

- GROUP BY 또한 ORDER BY와 같이 쿼리가 스트리밍된 처리를 할 수 없게 하는 처리 중 하나
- GROUP BY 절이 있는 쿼리에서는 HAVING 절을 사용 가능
→ **HAVING 절은 GROUP BY 결과에 대해 필터링**
- GROUP BY 작업도 인덱스를 사용하는 경우와 그렇지 못한 경우로 분류
    - **인덱스 스캔 방법, 루스 인덱스 스캔 방법**
    - **임시 테이블 사용하는 방법**

### ✔️ **인덱스 스캔을 이용하는 GROUP BY (타이트 인덱스 스캔)**

- 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 GROUP BY 칼럼으로 이미 인덱스가 있다면 그 **인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리**
- 유니크한 값의 수가 많을수록 성능이 향상
- 이미 정렬된 인덱스를 읽는 것이므로 쿼리 실행 시점에 **정렬 작업이나 내부 임시 테이블은 필요 X**

### ✔️ **루스 인덱스 스캔을 이용하는 GROUP BY**

- **인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것**
- **실행 계획:** `"Using index for group-by"` 코멘트가 표시
- 인덱스의 유니크한 값의 수가 적을수록 성능이 향상
- **별도의 임시 테이블 필요 X**

### ✔️ **임시 테이블을 사용하는 GROUP BY**

- **인덱스를 전혀 사용하지 못할 때 사용**
- **실행 계획:** 실`"Using temporary"` 메시지가 표시
- MySQL 8.0 버전부터는 묵시적인 **정렬은 더 이상 실행 X**
 → `"Using filesort"` 표시 X

## 📌 DISTINCT 처리

- **특정 칼럼의 유니크한 값만 조회하려면 `DISTINCT`를 사용**
- DISTINCT는 집합 함수와 함께 사용되는 경우와 집합 함수가 없는 경우로 분류
    - **SELECT DISTINCT ... (집합 함수 없는 경우)**
    - **집합 함수와 함께 사용된 DISTINCT**

### ✔️ **SELECT DISTINCT**

- `GROUP BY`와 동일한 방식으로 처리
- 아래 두 쿼리는 같은 작업 수행

```sql
ELECT DISTINCT emp_no FROM salaries;
SELECT emp_no FROM salaries GROUP BY emp_no;
```

- 주의) 특정 칼럼만 유니크하게 조회하는 것이 아니라 **조회하는 레코드(튜플) 전체를 유니크하게 조회**

### ✔️ **집합 함수와 함께 사용된 DISTINCT**

- `COUNT()`, `MIN()`, `MAX()` 같은 **집합 함수 내에서 사용된 `DISTINCT`**는 일반적인 `SELECT DISTINCT`와 다르게 해석
→ **조회하는 모든 칼럼의 조합이 유니크한 것들만 가져오기**

## 📌 내부 임시 테이블 활용

- **MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블(Internal temporary table)을 사용**
- 여기서의 임시 테이블은 `CREATE TEMPORARY TABLE` 명령으로 만든 임시 테이블과는 다르며, **쿼리의 처리가 완료되면 자동으로 삭제**

### ✔️ **메모리 임시 테이블과 디스크 임시 테이블**

- MySQL 8.0 버전부터는 **메모리는 TempTable이라는 스토리지 엔진**을 사용, 디스크에 저장되는 **임시 테이블은 InnoDB 스토리지 엔진**을 사용
- 디스크 저장 방식은 **MMAP 파일**로 기록하거나 **InnoDB 테이블**로 기록하는 방식 중 하나를 선택

### ✔️ **임시 테이블이 필요한 쿼리**

- `ORDER BY`와 `GROUP BY`에 명시된 칼럼이 다른 쿼리
- `ORDER BY`나 `GROUP BY`에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- `DISTINCT`와 `ORDER BY`가 동시에 쿼리에 존재하는 경우 또는 `DISTINCT`가 인덱스로 처리되지 못하는 쿼리
- `UNION`이나 `UNION DISTINCT`가 사용된 쿼리
- 쿼리의 실행 계획에서 `select_type`이 `DERIVED`인 쿼리

### ✔️ **임시 테이블이 디스크에 생성되는 경우**

- `UNION`이나 `UNION ALL`에서 SELECT되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
- `GROUP BY`나 `DISTINCT` 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
- 메모리 임시 테이블의 크기가 시스템 변수 설정값보다 큰 경우
