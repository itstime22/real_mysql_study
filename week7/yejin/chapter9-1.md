# 9. 옵티마이저와 힌트

# 9.1 쿼리 실행 절차

## 9.1.1 쿼리가 실행되는 과정

1. **SQL 파싱**
    - 요청된 SQL 문장을 잘개 쪼갬 → MySQL 서버가 이해할 수 있는 수준(**SQL 파스 트리**)으로 분리
    - 이 단계는 **SQL 파서**라는 모듈에서 담당하며, SQL 문장의 문법 오류를 확인
2. **최적화 및 실행 계획 수립**
    - SQL의 파싱 트리를 참조하여 다음과 같은 내용을 처리
        - 불필요한 조건 제거 및 복잡한 연산의 단순화
        - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
        - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
3. **실행**
    - 결정된 실행 계획에 따라 **스토리지 엔진으로부터 레코드를 읽어오고**, MySQL 엔진에서는 받은 레코드를 조인하거나 정렬하는 작업을 수행
    - MySQL 엔진과 스토리지 엔진이 함께 참여하여 처리

## 9.1.2 옵티마이저의 종류

- **규칙 기반 최적화**
    - 내부적으로 정해진 우선순위 규칙에 따라 실행 계획을 수립
    - 같은 쿼리에 대해서는 데이터의 상태와 관계없이 항상 같은 실행 계획을 만들어냄
    - 사용자의 데이터는 통계 정보가 매우 다양하기 때문에 현재는 거의 사용되지 않음
- **비용 기반 최적화**
    - 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 통계 정보를 확인해 실행 계획을 수립
    - 여러 방법 중 산출된 비용이 가장 적은 방법으로 쿼리를 실행
    - 현재 대부분의 RDBMS는 비용 기반 최적화 방식을 채택

# 9.2 기본 데이터 처리

## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

- 풀 테이블 스캔
    - 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미
- 풀 테이블 스캔을 선택하는 주요 조건
    - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우 (일반적으로 테이블이 페이지 1개로 구성된 경우)
    - `WHERE` 절이나 `ON` 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
    - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- 리드 어헤드
    - InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 **리드 어헤드** 작업이 자동으로 시작됨.
    - 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미
    - 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘김
    - 백그라운드 스레드는 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가시켜 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해 둠
    - 리드 어헤드는 풀 테이블 스캔뿐만 아니라 풀 인덱스 스캔에서도 동일하게 사용됨

## 9.2.2 병렬 처리

- 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리한다는 것을 의미
- `innodb_parallel_read_threads`라는 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지 변경 가능
- MySQL 8.0 버전에서는 아무런 `WHERE` 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리 가능
- 주의
    - 병렬 처리용 스레드 개수가 늘어날수록 쿼리 처리에 걸리는 시간은 줄어듬
    - 하지만 병렬 처리용 스레드 개수를 아무리 늘리더라도 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수도 있음을 주의

## 9.2.3 ORDER BY 처리

- 레코드 1~2건을 가져오는 쿼리를 제외하면 대부분의 `SELECT` 쿼리에서 정렬은 필수적으로 사용

### 9.2.3.1 인덱스 이용 vs. Filesort 이용

- 인덱스를 이용하는 방법
    - 장점
        - 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠름
    - 단점
        - `INSERT`, `UPDATE`, `DELETE` 작업 시 인덱스 추가/삭제 작업이 필요하므로 느림
        - 인덱스 때문에 디스크 공간과 버퍼 풀 메모리가 더 많이 필요
- Filesort를 이용하는 방법
    - 장점
        - 인덱스를 생성하지 않아도 되므로 인덱스 이용 시의 단점이 장점으로 바뀜
        - 정렬해야 할 레코드가 많지 않으면 메모리에서 처리되므로 충분히 빠름
    - 단점
        - 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느림
        - Filesort가 필요한 이유
            - 모든 정렬을 인덱스를 이용하도록 튜닝하기란 거의 불가능
            - 정렬 기준이 너무 많거나, `GROUP BY` 또는 `DISTINCT` 결과를 정렬해야 하는 경우, `UNION` 처럼 임시 테이블 결과를 다시 정렬해야 하는 경우 등이 이에 해당

### 9.2.3.2 정렬 알고리즘

- **싱글 패스 정렬 방식**
    - 소트 버퍼에 정렬 기준 칼럼을 포함해 `SELECT` 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 방식
- **투 패스 정렬 방식**
    - 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 `SELECT`할 칼럼을 가져오는 방식
- 정렬 처리 방법
    - 쿼리에 `ORDER BY`가 사용되면 다음 3가지 처리 방법 중 하나로 정렬이 처리
        - 인덱스를 사용한 정렬
        - 조인에서 드라이빙 테이블만 정렬
        - 조인에서 조인 결과를 임시 테이블로 저장 후 정렬
    - 일반적으로 아래로 갈수록 처리 속도는 떨어짐

### 9.2.3.3 스트리밍 방식 vs 버퍼링 방식

- **스트리밍(Streaming) 방식**
    - 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해 주는 방식을 의미
    - 인덱스를 사용한 정렬이 이 방식에 해당합니다.
- **버퍼링(Buffering) 방식**
    - `ORDER BY`나 `GROUP BY` 같은 처리는 쿼리의 결과가 스트리밍되는 것을 불가능하게 함
    - 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 하기 때문에 응답 속도가 느림

## 9.2.4 GROUP BY 처리

- 인덱스 스캔을 이용하는 GROUP BY (타이트 인덱스 스캔)
    - 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 `GROUP BY` 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리
    - 이러한 그루핑 방식을 사용하는 쿼리의 실행 계획에서는 `Extra` 칼럼에 별도로 `GROUP BY` 관련 코멘트나 임시 테이블 사용 또는 정렬 관련 코멘트가 표시 X
- 루스 인덱스 스캔을 이용하는 GROUP BY
    - 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미
    - 옵티마이저가 루스 인덱스 스캔을 사용할 때는 실행 계획의 `Extra` 칼럼에 `"Using index for group-by"` 코멘트 표시
    - 단일 테이블에 대해 수행되는 `GROUP BY` 처리에만 사용할 수 있으며, 인덱스의 유니크한 값의 수가 적을수록 성능 향상
- 임시 테이블을 사용하는 GROUP BY
    - 인덱스를 전혀 사용할 수 없는 상태에서 `GROUP BY`가 처리될 때 이 방식으로 처리됩니다.
    - **MySQL 8.0의 변화:** 이전 버전까지는 `GROUP BY`가 사용된 쿼리는 그루핑되는 칼럼을 기준으로 묵시적인 정렬까지 함께 수행했지만, **MySQL 8.0부터는 이러한 묵시적인 정렬은 더 이상 실행되지 않게 바뀌었습니다**.
    - **실행 계획:** `Extra` 칼럼에 **"Using temporary"** 메시지가 표시됩니다. 하지만 `ORDER BY` 절이 없으면 "Using filesort"는 표시되지 않습니다.

## 9.2.5 DISTINCT 처리

- SELECT DISTINCT ...
    - 단순히 조회되는 레코드 중에서 유니크한 레코드만 가져오고자 할 때 사용
    - 이 경우에는 `GROUP BY`와 동일한 방식으로 처리됨
    - 주의
        - `DISTINCT`는 `SELECT`하는 레코드(튜플)를 유니크하게 `SELECT`하는 것이지, 특정 칼럼만 유니크하게 조회하는 것이 아님.
        - 즉, `SELECT DISTINCT first_name, last_name`은 두 칼럼의 조합 전체가 유니크한 레코드를 가져오는 것
- 집합 함수와 함께 사용된 DISTINCT
    - `COUNT()` 또는 `MIN()`, `MAX()` 같은 집합 함수 내에서 `DISTINCT` 키워드 사용 가능
    - 이 경우에는 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들을 가져옴
    - 집합 함수 내의 `DISTINCT` 처리가 인덱스를 사용하지 못할 때는 항상 임시 테이블이 필요함. 하지만 이 경우 실행 계획의 `Extra` 칼럼에는 `"Using temporary"` 메시지가 출력되지 않음.

## 9.2.6 내부 임시 테이블 활용

- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블을 사용함
- 일반적으로 MySQL 엔진이 사용하는 임시 테이블은 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨짐

### 9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블

- **메모리용 임시 테이블**
    - 기존 `MEMORY` 스토리지 엔진 대신 가변 길이 타입을 지원하는 `TempTable` 스토리지 엔진을 기본으로 사용
- **디스크용 임시 테이블**
    - 기존 `MyISAM` 대신 트랜잭션 지원이 가능한 `InnoDB` 스토리지 엔진을 사용하도록 개선
- **크기 제어**
    - 임시 테이블의 크기가 1GB보다 커지는 경우 MySQL 서버는 메모리의 임시 테이블을 디스크로 기록하게 됨

### 9.2.6.2 임시 테이블이 필요한 쿼리

- 다음과 같은 패턴의 쿼리는 MySQL 엔진에서 별도의 데이터 가공 작업을 필요로 하므로 대표적으로 내부 임시 테이블을 생성함
    - `ORDER BY`와 `GROUP BY`에 명시된 칼럼이 다른 쿼리
    - `ORDER BY`나 `GROUP BY`에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
    - `DISTINCT`와 `ORDER BY`가 동시에 쿼리에 존재하는 경우 또는 `DISTINCT`가 인덱스로 처리되지 못하는 쿼리
    - `UNION`이나 `UNION DISTINCT`가 사용된 쿼리
    - 쿼리의 실행 계획에서 `select_type`이 `DERIVED`인 쿼리

### 9.2.6.3 임시 테이블이 디스크에 생성되는 경우

- 내부 임시 테이블은 기본적으로 메모리에 만들어지지만, 다음과 같은 조건을 만족하면 메모리 임시 테이블을 사용할 수 없어 디스크 기반의 임시 테이블을 사용함.
    - `UNION`이나 `UNION ALL`에서 `SELECT`되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
    - `GROUP BY`나 `DISTINCT` 칼럼에서 **512바이트 이상**인 크기의 칼럼이 있는 경우
    - 메모리 임시 테이블의 크기가 `tmp_table_size` 또는 `max_heap_table_size` 시스템 변수보다 크거나 `temptable_max_ram` 변수 값보다 큰 경우

### 9.2.6.4 임시 테이블 관련 상태 변수

- 실행 계획에서 "Using temporary"가 표시되었다고 해서 임시 테이블이 메모리에서 처리되었는지 디스크에서 처리되었는지는 알 수 없음
- 이를 확인하려면 다음과 같이 **상태 변수**를 확인해야 함
    
    ```sql
    mysql> FLUSH STATUS;
    mysql> -- 쿼리 실행 --
    mysql> SHOW SESSION STATUS LIKE 'Created_tmp%';
    ```
    
    - **`Created_tmp_tables`**: 쿼리 처리를 위해 만들어진 내부 임시 테이블의 전체 개수(메모리+디스크)를 누적
    - **`Created_tmp_disk_tables`**: 디스크에 내부 임시 테이블이 만들어진 개수만 누적

> 총 정리
> 
- SQL 성능이 느릴 때 가장 먼저 실행 계획을 확인하자.
    - ex) EXPLAIN SELECT * FROM employees WHERE emp_no = 10001;
    - type, key, rows, Extra 확인
        - type: 인덱스를 탔는지(range, ref), 전체를 다 읽었는지 (ALL) 보여줌
        - key: 어떤 인덱스 쓰기로 결정했는지 확인
        - rows: 예상 작업량
        - Extra: Using filesort나 Using temporary 뜨는지 확인
            - Using filesort나 Using temporary가 보인다면 정렬과 가공 작업이 인덱스 도움 없이 처리되고 있다는 신호
            - Using filesort
                - 인덱스 정렬을 못 하고 있는 것
                - 가능하면 인덱스를 이용한 정렬이 되도록 인덱스 구성 변경
                - 불가능하다면 최소한 드라이빙 테이블만 정렬하도록 유도
            - Using temporary
                - DB 내부적으로 메모리나 디스크에 임시 테이블을 만든 것
                - 데이터 양이 많아질 때를 대비해 인덱스나 쿼리 구조 개선 필요